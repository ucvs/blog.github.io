{"meta":{"title":"欢迎来到唯美的网站","subtitle":null,"description":"weimei","author":"Aestheticism","url":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848"},"pages":[{"title":"404","date":"2018-03-15T23:35:15.000Z","updated":"2018-03-15T23:35:15.985Z","comments":true,"path":"404/index-2.html","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/404/index-2.html","excerpt":"","text":""},{"title":"404","date":"2018-03-15T22:38:00.000Z","updated":"2018-03-15T22:38:00.069Z","comments":true,"path":"404/index-1.html","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/404/index-1.html","excerpt":"","text":""},{"title":"404","date":"2018-03-16T08:03:45.000Z","updated":"2018-03-16T08:03:45.245Z","comments":true,"path":"404/index-3.html","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/404/index-3.html","excerpt":"","text":""},{"title":"404","date":"2018-03-15T22:31:42.000Z","updated":"2018-03-15T22:31:42.861Z","comments":true,"path":"404/index.html","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/404/index.html","excerpt":"","text":""},{"title":"search","date":"2018-03-15T22:37:50.000Z","updated":"2018-03-15T22:37:50.611Z","comments":true,"path":"search/index-1.html","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/search/index-1.html","excerpt":"","text":""},{"title":"about","date":"2018-03-16T20:25:01.000Z","updated":"2018-03-16T20:55:36.568Z","comments":true,"path":"about/index.html","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/about/index.html","excerpt":"","text":""},{"title":"search","date":"2018-03-15T23:35:07.000Z","updated":"2018-03-15T23:35:07.638Z","comments":true,"path":"search/index-2.html","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/search/index-2.html","excerpt":"","text":""},{"title":"search","date":"2018-03-16T08:03:35.000Z","updated":"2018-03-16T08:03:35.042Z","comments":true,"path":"search/index-3.html","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/search/index-3.html","excerpt":"","text":""},{"title":"search","date":"2018-03-15T22:31:29.000Z","updated":"2018-03-15T22:31:29.882Z","comments":true,"path":"search/index.html","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/search/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-03-16T20:56:45.000Z","updated":"2018-03-16T20:56:45.814Z","comments":true,"path":"tags/index.html","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-03-16T20:52:19.000Z","updated":"2018-03-16T21:03:16.114Z","comments":false,"path":"categories/index.html","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"OkHttp框架读书总结笔记","slug":"OkHttpReadingNotes","date":"2015-02-11T03:55:21.000Z","updated":"2018-03-18T04:32:48.958Z","comments":true,"path":"2015/02/11/OkHttpReadingNotes/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2015/02/11/OkHttpReadingNotes/","excerpt":"","text":"原CSDN博客已弃用，文章会逐渐迁移过来。 转帖请注明本文出自weimeig的博客（http://blog.csdn.net/weimeig/article/details/78656734），请尊重他人的辛勤劳动成果，谢谢 一、添加依赖 build.gradle dependencies { compile &apos;com.squareup.okhttp3:okhttp:3.2.0&apos; compile &apos;com.squareup.okio:okio:1.7.0&apos; } 权限: &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; HelloOkhttp import java.io.IOException; import okhttp3.OkHttpClient; import okhttp3.Request; import okhttp3.Response; /** * Created by Administrator on 2017/11/27. */ public class HelloOkhttp { public static void main(String [] args) throws IOException { OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder(). url(&quot;http://www.baidu.com&quot;).build(); try { Response response = client.newCall(request).execute(); if (response.isSuccessful()) { System.out.println(response.body().string()); } } catch (IOException e) { e.printStackTrace(); } } } QueryHttp import java.io.IOException; import okhttp3.HttpUrl; import okhttp3.OkHttpClient; import okhttp3.Request; import okhttp3.Response; /** * Created by Administrator on 2017/11/27. */ public class QueryHttp { public static void main(String args[]) { OkHttpClient client = new OkHttpClient(); HttpUrl httpUrl = HttpUrl.parse(&quot;https://api.heweather.com/x3/weather&quot;). newBuilder(). addQueryParameter(&quot;city&quot;, &quot;beijing&quot;). addQueryParameter(&quot;key&quot;, &quot;d17ce22ec5404ed883e1cfcaca0ecaa7&quot;). build(); String url = httpUrl.toString(); System.out.println(httpUrl.toString()); Request request = new Request.Builder().url(url).build(); try { Response response = client.newCall(request).execute(); if (response.isSuccessful()) { System.out.println(response.body().string()); } } catch (IOException e) { e.printStackTrace(); } } } HeadHttp import java.io.IOException; import okhttp3.Headers; import okhttp3.OkHttpClient; import okhttp3.Request; import okhttp3.Response; /** * Created by Administrator on 2017/11/27. */ /** * 请求头 */ public class HeadHttp { public static void HadeHttp(String url){ OkHttpClient client =new OkHttpClient(); Request request = new Request.Builder().url(url). addHeader(&quot;User-Agent&quot;,&quot;from nate http&quot;).build(); try { Response response = client.newCall(request).execute(); if(response.isSuccessful()){ Headers headers = response.headers(); for(int i=0;i&lt;headers.size();i++){ System.out.println(headers.name(i)+&quot;:&quot;+headers.value(i)); } } } catch (IOException e) { e.printStackTrace(); } } public static void main(String []args){ HadeHttp(&quot;http://www.baidu.com&quot;); } } 同步和异步请求比较 import java.io.IOException; import okhttp3.Call; import okhttp3.Callback; import okhttp3.OkHttpClient; import okhttp3.Request; import okhttp3.Response; /** * Created by Administrator on 2017/11/27. */ /**同步 * */ public class AsyncHttp { public static void SendHttp(String url){ OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder().url(url).build(); try { Response response = client.newCall(request).execute(); if (response.isSuccessful()){ System.out.println(response.body().string()); } } catch (IOException e) { e.printStackTrace(); } } /** *异步 * */ public static void SendAsyncHttp(String url){ System.out.println(Thread.currentThread().getId()); OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder().url(url).build(); client.newCall(request).enqueue(new Callback() { @Override public void onFailure(Call call, IOException e) { } @Override public void onResponse(Call call, Response response) throws IOException { if (response.isSuccessful()){ System.out.println(Thread.currentThread().getId()); } } }); } public static void main(String [] args){ SendAsyncHttp(&quot;http://www.baidu.com&quot;); // SendHttp(&quot;http://www.baidu.com&quot;); } }","categories":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Android/"}]},{"title":"微信支付及支付宝支付集成","slug":"WeChatAlipayPayIntegr","date":"2014-12-11T04:19:15.000Z","updated":"2018-03-18T04:25:57.390Z","comments":true,"path":"2014/12/11/WeChatAlipayPayIntegr/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2014/12/11/WeChatAlipayPayIntegr/","excerpt":"","text":"文章转载自互联网 1.微信支付 1.微信官方的集成文档 2.微信官方资源下载 首先官方文档实在是没有看懂，里面有很多东西都没有提及到，反正当时我看的时候就没有看懂可能是能力有限吧！ 先说一下我们这边的需求吧，我们这边订单处理是在服务器，没有在app内进行，一些字段都是从服务器返回的，这里只要请求之后，唤起微信支付就算是完成了，还是很简单的一个操作，下面我们就一步一步往下说吧！集成步骤如下：1.首先就是导入最新的SDK，这个从微信官方资源下载处就可以下载（这里就不说了）2.添加必要的权限 &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt; 3.创建一个wxapi的包并且创建一个WXEntryActivity类这里有几点要注意以下： 1.首先这个包必须在你项目的根目录下创建的，例如应用程序的包名为net.sourceforge.simcpux，则新添加的应该在net.sourceforge.simcpux.wxapi下面） 2.在AndroidManifest中添加相应的标签 &lt;activity android:name=&quot;.wxapi.WXEntryActivity&quot; android:configChanges=&quot;keyboardHidden|orientation|screenSize&quot; android:exported=&quot;true&quot; android:screenOrientation=&quot;portrait&quot; android:theme=&quot;@android:style/Theme.Translucent.NoTitleBar&quot;/&gt; 4.关于APPID存放问题 关于这个APPID的存放，因为做了分享，所以我就直接存放到本地了的静态字段中了，还有就是从服务器请求，其实从服务器请求我有一点我不太明白之后再说！5.创建一个WXPayEntryActivity类 创建的这个类我就直接放在wxapi中了，不知都放在别的地方会不会有什么问题，没有尝试过。这个类就是用来支付回调的类了。关于这个类有几点说明： 1.这个类是集成Activity的实现IWXAPIEventHandler接口的，别忘了在AndroidManifest注册，否则不走回调的！ &lt;activity android:name=&quot;.wxapi.WXPayEntryActivity&quot; android:exported=&quot;true&quot; android:launchMode=&quot;singleTop&quot;/&gt; 2.在onCreat()方法中要注册到微信，这里要注意这个是你微信成功签名的那个APPID private IWXAPI api; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); //这里面的APPID就是存放在本地的微信的ID api = WXAPIFactory.createWXAPI(this, Constants.ACCOUNT.APP_ID); api.handleIntent(getIntent(), this); } 3.在onResp(BaseResp resp)方法中处理回调数据，也就是处理回调失败啊，成功啊什么的！ @Override public void onResp(BaseResp resp) { Logger.e(&quot;WXPayEntryActivity回调微信支付的结果errCode = &quot; + resp.errCode); if (resp.getType() == ConstantsAPI.COMMAND_PAY_BY_WX) { int errCode = resp.errCode; if (errCode == -1) {/*支付失败*/ Toast.makeText(this, &quot;支付失败&quot;, Toast.LENGTH_LONG).show(); } else if (errCode == 0) {/*支付成功*/ Toast.makeText(this, &quot;支付成功&quot;, Toast.LENGTH_SHORT).show(); EventBusUtils.post(new EventBusWechatGoldBean()); } else if (errCode == -2) {/*取消支付*/ Toast.makeText(this, &quot;取消支付&quot;, Toast.LENGTH_LONG).show(); } finish(); } } 6.之后就可以在相应的地方从服务器获取相应的参数调用微信支付了 调用的代码如下： /** * 唤起微信充值界面 */ private void payWechat(WechatGoldBean wechatGoldBean) { PayReq req = new PayReq(); req.appId = wechatGoldBean.getAppid(); req.partnerId = wechatGoldBean.getPartnerid(); req.prepayId = wechatGoldBean.getPrepayid(); req.nonceStr = wechatGoldBean.getNoncestr(); req.timeStamp = wechatGoldBean.getTimestamp(); req.packageValue = &quot;Sign=WXPay&quot;; req.sign = wechatGoldBean.getSign(); IWXAPI api = WXAPIFactory.createWXAPI(mContext, wechatGoldBean.getAppid()); api.sendReq(req); } 这里WechatGoldBean是从服务器请求来的实体类，这里面封装了关于微信支付的所有订单信息，这样做的好处就是生成订单服务器做比较安全，第二也省去了自己的麻烦。到了这里基本上都能唤起微信支付了常见问题： 关于微信的签名要说明的问题：首先按照微信的签名的话，一般步骤都可以往下走，但是有一点需要注意就是签完名之后，如果你打包成正式版的话也就是releasea签名的话要用正式的包安装才能唤起微信，否则会出错的，如果要是想使用Dug签名的话，你要把签名后的keystore替换掉android studio的默认签名就可以使用了。关于微信支付能只能想到这么多了，基本上集成就这么多问题，有什么不懂得欢迎在下方留言，看到了我会第一时间回复！！！2.支付宝支付 1.支付宝官方集成文档2.支付宝官方资源下载 其实支付宝支付的话还是比较简单的按照Demo集成的话基本上没有什么问题就是导入几个类就可以了。 还是先说一下我们这边的需求，还是订单处理在服务器这边，没有在app内进行，一些字段都是从服务器返回的，这里只要请求之后，唤起支付宝支付就算完成了，比较简单，下面一步一步往下说吧！集成步骤如下：1.首先就是导入最新的SDK，这个从支付宝官方资源下载处就可以下载（这里就不说了）2.添加必要的权限 &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt; 3.在AndroidManifest中添加相应的标签 &lt;activity android:name=&quot;com.alipay.sdk.app.H5PayActivity&quot; android:configChanges=&quot;orientation|keyboardHidden|navigation&quot; android:exported=&quot;false&quot; android:screenOrientation=&quot;behind&quot; &gt; &lt;/activity&gt; &lt;activity android:name=&quot;com.alipay.sdk.auth.AuthActivity&quot; android:configChanges=&quot;orientation|keyboardHidden|navigation&quot; android:exported=&quot;false&quot; android:screenOrientation=&quot;behind&quot; &gt; &lt;/activity&gt; 4.支付接口调用 这里说明一下，支付宝调用的时候必须在异步线程中调用！切记 public void payAlipay(final ALipayGoldBean aLipayGoldBean) { Runnable payRunnable = new Runnable() { @Override public void run() { PayTask alipay = new PayTask((DiamondActivity) mContext); Map&lt;String, String&gt; result = alipay.payV2(aLipayGoldBean.getPayInfo(), true); Message msg = new Message(); msg.what = SDK_PAY_FLAG; msg.obj = result; mHandler.sendMessage(msg); } }; Thread payThread = new Thread(payRunnable); payThread.start(); } 这里说明一下：这个ALipayGoldBean是从服务器请求过来的，里面就一个payInfo参数，其实就是payV2()所需要的定单的信息(orderInfo)！5.支付结果的处理 官方文档上说有两种处理方式，但是作为APP我只按第一种处理方式进行的，第二种没有研究！ private Handler mHandler = new Handler() { @Override public void handleMessage(Message msg) { switch (msg.what) { case SDK_PAY_FLAG: @SuppressWarnings(&quot;unchecked&quot;) PayResult payResult = new PayResult((Map&lt;String, String&gt;) msg.obj); String resultStatus = payResult.getResultStatus(); // 判断resultStatus 为9000则代表支付成功 if (TextUtils.equals(resultStatus, &quot;9000&quot;)) {/*支付成功*/ Toast.makeText(mContext, &quot;支付成功&quot;, Toast.LENGTH_SHORT).show(); } else {/*支付失败*/ Toast.makeText(mContext, &quot;支付失败&quot;, Toast.LENGTH_SHORT).show(); } break; } } }; 这里有几点说明的问题：1.这个PayResult从Demo中直接复制过来就行，要不没有的；如果你不想复制，好的在下面： public class PayResult { private String resultStatus; private String result; private String memo; public PayResult(Map&lt;String, String&gt; rawResult) { if (rawResult == null) { return; } for (String key : rawResult.keySet()) { if (TextUtils.equals(key, &quot;resultStatus&quot;)) { resultStatus = rawResult.get(key); } else if (TextUtils.equals(key, &quot;result&quot;)) { result = rawResult.get(key); } else if (TextUtils.equals(key, &quot;memo&quot;)) { memo = rawResult.get(key); } } } @Override public String toString() { return &quot;resultStatus={&quot; + resultStatus + &quot;};memo={&quot; + memo + &quot;};result={&quot; + result + &quot;}&quot;; } /** * @return the resultStatus */ public String getResultStatus() { return resultStatus; } /** * @return the memo */ public String getMemo() { return memo; } /** * @return the result */ public String getResult() { return result; } } 2.关于Handler内存泄漏的问题，自己可以改的，如果改不了百度一下就可以了。至此支付宝支付就算集成完毕了，是不是很简单！作为小白的我们真的要多学习，多看别人的代码，学习这个东西就是这样，不论什么天才和小白，没有什么捷径可以走，只有不断的学习才能跟得上时代，不被淘汰！座右铭：只有自己强大才能无所畏惧！","categories":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Android/"}]},{"title":"Java接口回调，Android接口回调读书笔记","slug":"InterfaceCallback","date":"2014-05-13T04:04:35.000Z","updated":"2018-03-18T04:49:39.863Z","comments":true,"path":"2014/05/13/InterfaceCallback/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2014/05/13/InterfaceCallback/","excerpt":"","text":"原CSDN博客已弃用，文章会逐渐迁移过来。 单看文章比较难理解，照着多敲几遍代码就理解了 回调就是A类中调用B类中的某个方法C，然后B类中反过来调用A类中的方法D，D这个方法就叫回调方法，这样子说你是不是有点晕晕的，其实我刚开始也是这样不理解，看了人家说比较经典的回调方式： Class A实现接口CallBack callback——背景1 class A中包含一个class B的引用b ——背景2 class B有一个参数为callback的方法f(CallBack callback) ——背景3 A的对象a调用B的方法 f(CallBack callback) ——A类调用B类的某个方法 C 然后b就可以在f(CallBack callback)方法中调用A的方法 ——B类调用A类的某个方法D 大家都喜欢用打电话的例子，好吧，为了跟上时代，我也用这个例子好了，我这个例子采用异步加回调 有一天小王遇到一个很难的问题，问题是“1 + 1 = ?”，就打电话问小李，小李一下子也不知道，就跟小王说，等我办完手上的事情，就去想想答案，小王也不会傻傻的拿着电话去等小李的答案吧，于是小王就对小李说，我还要去逛街，你知道了答案就打我电话告诉我，于是挂了电话，自己办自己的事情，过了一个小时，小李打了小王的电话，告诉他答案是2 /** * 这是一个回调接口 * @author xiaanming * */ public interface CallBack { /** * 这个是小李知道答案时要调用的函数告诉小王，也就是回调函数 * @param result 是答案 */ public void solve(String result); } /** * 这个是小王 * @author xiaanming * 实现了一个回调接口CallBack，相当于-----&gt;背景一 */ public class Wang implements CallBack { /** * 小李对象的引用 * 相当于-----&gt;背景二 */ private Li li; /** * 小王的构造方法，持有小李的引用 * @param li */ public Wang(Li li){ this.li = li; } /** * 小王通过这个方法去问小李的问题 * @param question 就是小王要问的问题,1 + 1 = ? */ public void askQuestion(final String question){ //这里用一个线程就是异步， new Thread(new Runnable() { @Override public void run() { /** * 小王调用小李中的方法，在这里注册回调接口 * 这就相当于A类调用B的方法C */ li.executeMessage(Wang.this, question); } }).start(); //小网问完问题挂掉电话就去干其他的事情了，诳街去了 play(); } public void play(){ System.out.println(&quot;我要逛街去了&quot;); } /** * 小李知道答案后调用此方法告诉小王，就是所谓的小王的回调方法 */ @Override public void solve(String result) { System.out.println(&quot;小李告诉小王的答案是---&gt;&quot; + result); } } /** * 这个就是小李啦 * @author xiaanming * */ public class Li { /** * 相当于B类有参数为CallBack callBack的f()----&gt;背景三 * @param callBack * @param question 小王问的问题 */ public void executeMessage(CallBack callBack, String question){ System.out.println(&quot;小王问的问题---&gt;&quot; + question); //模拟小李办自己的事情需要很长时间 for(int i=0; i&lt;10000;i++){ } /** * 小李办完自己的事情之后想到了答案是2 */ String result = &quot;答案是2&quot;; /** * 于是就打电话告诉小王，调用小王中的方法 * 这就相当于B类反过来调用A的方法D */ callBack.solve(result); } } /** * 测试类 * @author xiaanming * */ public class Test { public static void main(String[]args){ /** * new 一个小李 */ Li li = new Li(); /** * new 一个小王 */ Wang wang = new Wang(li); /** * 小王问小李问题 */ wang.askQuestion(&quot;1 + 1 = ?&quot;); } } 通过上面的那个例子你是不是差不多明白了回调机制呢，上面是一个异步回调，我们看看同步回调吧，onClick（）方法 现在来分析分析下Android View的点击方法onclick（）;我们知道onclick()是一个回调方法，当用户点击View就执行这个方法，我们用Button来举例好了 //这个是View的一个回调接口 /** * Interface definition for a callback to be invoked when a view is clicked. */ public interface OnClickListener { /** * Called when a view has been clicked. * * @param v The view that was clicked. */ void onClick(View v); } package com.example.demoactivity; import android.app.Activity; import android.os.Bundle; import android.view.View; import android.view.View.OnClickListener; import android.widget.Button; import android.widget.Toast; /** * 这个就相当于Class A * @author xiaanming * 实现了 OnClickListener接口----&gt;背景一 */ public class MainActivity extends Activity implements OnClickListener{ /** * Class A 包含Class B的引用-----&gt;背景二 */ private Button button; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); button = (Button)findViewById(R.id.button1); /** * Class A 调用View的方法,而Button extends View-----&gt;A类调用B类的某个方法 C */ button.setOnClickListener(this); } /** * 用户点击Button时调用的回调函数，你可以做你要做的事 * 这里我做的是用Toast提示OnClick */ @Override public void onClick(View v) { Toast.makeText(getApplication(), &quot;OnClick&quot;, Toast.LENGTH_LONG).show(); } } 下面是View类的setOnClickListener方法，就相当于B类咯，只把关键代码贴出来 /** * 这个View就相当于B类 * @author xiaanming * */ public class View implements Drawable.Callback, KeyEvent.Callback, AccessibilityEventSource { /** * Listener used to dispatch click events. * This field should be made private, so it is hidden from the SDK. * {@hide} */ protected OnClickListener mOnClickListener; /** * setOnClickListener()的参数是OnClickListener接口------&gt;背景三 * Register a callback to be invoked when this view is clicked. If this view is not * clickable, it becomes clickable. * * @param l The callback that will run * * @see #setClickable(boolean) */ public void setOnClickListener(OnClickListener l) { if (!isClickable()) { setClickable(true); } mOnClickListener = l; } /** * Call this view&apos;s OnClickListener, if it is defined. * * @return True there was an assigned OnClickListener that was called, false * otherwise is returned. */ public boolean performClick() { sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED); if (mOnClickListener != null) { playSoundEffect(SoundEffectConstants.CLICK); //这个不就是相当于B类调用A类的某个方法D，这个D就是所谓的回调方法咯 mOnClickListener.onClick(this); return true; } return false; } } 这个例子就是Android典型的回调机制，看完这个你是不是更进一步的理解了回调机制呢？ 线程run()也是一个回调方法，当执行Thread的start（）方法就会回调这个run()方法，还有处理消息都比较经典等等 案例二、 接口回调简单理解就是：类A中调用B类的中方法C，而B又反过去调用A中的方法D，然后D称为A的回调方法。是不是心中有一万只草泥马在奔腾，到底说的是什么。感觉像是你中有我，我中有你，纠缠不清。举个通俗易懂的例子，比如顾客是A，厨师是B。面粉是接口Callback。然后面粉的吃法D是在顾客A的手中，厨师B有包子的做法C。现在需求是A有面粉，想吃包子，但是A是不会做包子，就需要去找厨师，让他调方法C做包子，A就把面粉Callback给了厨师，至于厨师怎么做，A不管，A只要你做好了给我一个结果（包子）就OK了。至于包子怎么吃，我是直接吃，还是蘸点醋吃，那是A的事了（A怎么吃的过程就是方法D里具体执行的代码）。下面结合一个简单的例子看就容易多了。首先是定义接口（面粉）： package com.example.interfacecallbackdemo; public interface Callback { //因为是一堆面粉，肯定是没法吃的，所以没有具体的方法体，俗称“吃法” public void D(String result); } 然后定义A类（客户）： package com.example.interfacecallbackdemo; public class A implements Callback{ /** * B类引用 */ private B b; public A(B b) { this.b = b; } /** * A类通过该方法调用B的方法C（可理解为找到厨师并将面粉给他）。 */ public void selectMenu(){ b.C(this); } /** * A类中的D方法，也称为A类的回调方法（厨师做好包子将包子（result）返回给顾客A） */ @Override public void D(String result) { System.out.print(result); } } 然后是B类： package com.example.interfacecallbackdemo; public class B { /** * B类的C方法（接受面粉Callback,然后开工做包子，做好后返回给客户A）。 */ public void C(Callback callback){ String result = &quot;2&quot;; callback.D(result); } } 再加上一个执行的对象，我是利用android中button调用的： package com.example.interfacecallbackdemo; import android.app.Activity; import android.os.Bundle; import android.view.Menu; import android.view.MenuItem; import android.view.View; import android.view.View.OnClickListener; import android.widget.Button; public class MainActivity extends Activity implements OnClickListener{ private A a; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); findViewById(R.id.btn_main) .setOnClickListener(this); a = new A(new B()); } @Override public void onClick(View v) { switch (v.getId()) { case R.id.btn_main: a.selectMenu(); break; default: break; } } } （ABCD分别对应什么自己脑补，很easy吧）前面说的是A 调用B中的方法C，B又反过来调用A中的方法D。在代码中我就直接用ABCD ,简单、直接、粗暴。但是，B类的C方法的参数不必一定要把Callback作为参数，如果C方法中没有这个参数，那在B类中一定要在其它地方把Callback接收进来。比如，我把B类稍微改动一下： package com.example.interfacecallbackdemo; public class B { private Callback callback; public B(Callback callback){ this.callback = callback; } /** * B类的C方法 */ public void C(){ String result = &quot;2&quot;; callback.D(result); } } 此时A类也要做相应的调整： package com.example.interfacecallbackdemo; import android.util.Log; public class A { /** * B类引用 */ private B b; /** * A类同过该方法调用B类的C方法 */ public void selectMenu(){ b = new B(new Callback() { @Override public void D(String result) { System.out.print(result); } }); b.C(); } } 呃，这个算是标准版的变异版，其实也是很简单的，毕竟这种可能是大家项目中实际中会见到而不至于弄不清楚，但是有一点，C方法中一定会有接口的实例对象调用其抽象方法。其实我们不需要按接口回调的定义去对比，重要的是理解其原理机制，只需记住，哪个类传递Callback实例对象过去的，就是我们所说的A，接受的就是B。接口回调在android中是非常常见的，典型的就是各种监听器了，如果去分析下源码，你就会发现跟上面得那个例子大同小异。","categories":[{"name":"Java","slug":"Java","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Java/"}]},{"title":"Retrofit框架读书总结笔记（一）","slug":"RetrofitReadingNotesOne","date":"2014-05-11T03:55:21.000Z","updated":"2018-03-18T04:29:21.995Z","comments":true,"path":"2014/05/11/RetrofitReadingNotesOne/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2014/05/11/RetrofitReadingNotesOne/","excerpt":"","text":"原CSDN博客已弃用，文章会逐渐迁移过来。 转帖请注明本文出自weimeig的博客（http://blog.csdn.net/weimeig/article/details/78656178），请尊重他人的辛勤劳动成果，谢谢 一、添加依赖 build.gradle dependencies { compile &apos;com.squareup.retrofit2:retrofit:2.0.2&apos; // Retrofit库 compile &apos;com.squareup.okhttp3:okhttp:3.1.2&apos; // Okhttp库 } 点击右上角Sync Now 二、 （1）RestService类 import java.util.WeakHashMap; import okhttp3.MultipartBody; import okhttp3.RequestBody; import okhttp3.ResponseBody; import retrofit2.Call; import retrofit2.http.Body; import retrofit2.http.DELETE; import retrofit2.http.FieldMap; import retrofit2.http.FormUrlEncoded; import retrofit2.http.GET; import retrofit2.http.Multipart; import retrofit2.http.POST; import retrofit2.http.PUT; import retrofit2.http.Part; import retrofit2.http.QueryMap; import retrofit2.http.Streaming; import retrofit2.http.Url; /** * Created by Administrator on 2017/11/28. */ public interface RestService { @GET Call&lt;String&gt; get(@Url String url, @QueryMap WeakHashMap&lt;String, Object&gt; params); @FormUrlEncoded @POST Call&lt;String&gt; post(@Url String url, @FieldMap WeakHashMap&lt;String, Object&gt; params); @POST Call&lt;String&gt; postRaw(@Url String url, @Body RequestBody body); @FormUrlEncoded @PUT Call&lt;String&gt; put(@Url String url, @FieldMap WeakHashMap&lt;String, Object&gt; params); @PUT Call&lt;String&gt; putRaw(@Url String url, @Body RequestBody body); @DELETE Call&lt;String&gt; delete(@Url String url, @QueryMap WeakHashMap&lt;String, Object&gt; params); @Streaming @GET Call&lt;ResponseBody&gt; download(@Url String url, @QueryMap WeakHashMap&lt;String, Object&gt; params); @Multipart @POST Call&lt;String&gt; upload(@Url String url, @Part MultipartBody.Part file); }","categories":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Android/"}]},{"title":"AndroidStudio导入网上下载的代码慢及AndroidStudio不提示代码的解决方法","slug":"ASImportCodeNotPrompt","date":"2014-03-18T04:01:25.000Z","updated":"2018-03-18T04:03:35.817Z","comments":true,"path":"2014/03/18/ASImportCodeNotPrompt/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2014/03/18/ASImportCodeNotPrompt/","excerpt":"","text":"原CSDN博客已弃用，文章会逐渐迁移过来。 转帖请注明本文出自weimeig的博客（http://blog.csdn.net/weimeig/article/details/78854345），请尊重他人的辛勤劳动成果，谢谢 当出现AndroidStudio导入网上下载的代码慢及AndroidStudio不提示代码时，多数是因为Google被墙，导致gradle无法更新下来。 解决的方法是，先在本地创建一个Android项目，然后找到 随后再找到 完成这两步的目的是，通过找到本地的gradle配置，将网上下载的不同配置的项目的gradle配置改成读本地配置，来解决Google被墙无法更新网上可行版本的问题。通常设置完这两个地方，再点击一下AndroidStudio上方工具栏里的BuiId下的Clean Project ，结束后点击RebuiId Project,然后再点击一下这个按钮， 同步一下，问题就可以解决了 一般来说，网上下载的项目更新慢，或编译器无代码提示，都是因为这个原因引起。","categories":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Android/"}]},{"title":"Android第三方分享集成","slug":"AndroidThirdShare","date":"2014-03-18T03:55:21.000Z","updated":"2018-03-18T04:00:49.647Z","comments":true,"path":"2014/03/18/AndroidThirdShare/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2014/03/18/AndroidThirdShare/","excerpt":"","text":"原CSDN博客已弃用，文章会逐渐迁移过来。 转帖请注明本文出自weimeig的博客（http://blog.csdn.net/weimeig/article/details/78818943），请尊重他人的辛勤劳动成果，谢谢 一、环境集成 二、调用方法 一、环境集成 请看我的另一篇文章，里面详尽的介绍了整个集成的流程。分享只是在那个前提下多写一个分享的方法。 文章链接：http://blog.csdn.net/weimeig/article/details/78818085 二、调用方法 `/** * 第三方分享方法 * Created by weimei on 2017/12/16. * Email:ucvs@qq.com */ public void share(){ OnekeyShare oks = new OnekeyShare(); //关闭sso授权 oks.disableSSOWhenAuthorize(); // 分享时Notification的图标和文字 2.5.9以后的版本不 调用此方法 //oks.setNotification(R.drawable.ic_launcher, getString(R.string.app_name)); // title标题，印象笔记、邮箱、信息、微信、人人网和QQ空间使用 oks.setTitle(&quot;分享&quot;); // titleUrl是标题的网络链接，仅在人人网和QQ空间使用 oks.setTitleUrl(&quot;http://blog.csdn.net/weimeig&quot;); // text是分享文本，所有平台都需要这个字段 oks.setText(&quot;我是分享文本&quot;); // imagePath是图片的本地路径，Linked-In以外的平台都支持此参数 oks.setImageUrl(&quot;http://www.ld12.com/upimg358/20160130/23120952396496.jpg&quot;);//确保SDcard下面存在此张图片 // url仅在微信（包括好友和朋友圈）中使用 oks.setUrl(&quot;http://blog.csdn.net/weimeig&quot;); // comment是我对这条分享的评论，仅在人人网和QQ空间使用 oks.setComment(&quot;我是测试评论文本&quot;); // site是分享此内容的网站名称，仅在QQ空间使用 oks.setSite(getString(R.string.app_name)); // siteUrl是分享此内容的网站地址，仅在QQ空间使用 oks.setSiteUrl(&quot;http://blog.csdn.net/weimeig&quot;); oks.setCallback(new PlatformActionListener() { @Override public void onComplete(Platform platform, int i, HashMap&lt;String, Object&gt; hashMap) { /** * 不得到优惠券 */ //分享成功逻辑在这里处理 } @Override public void onError(Platform platform, int i, Throwable throwable) { //分享失败逻辑在这里处理 } @Override public void onCancel(Platform platform, int i) { //分享取消逻辑在这里处理 } }); // 启动分享GUI oks.show(this); }` 调用时候，在调用的地方使用 share(); 即可 如果分享的图标和渠道，不想要那么多，在项目下的app文件夹下的libs文件夹内删除对应的jar包即可。 例如不想要微信分享，直接删除ShareSDK-Wechat-Favorite-3.1.2.jar这个jar包，分享的时候就没有这个图标和对应的分享渠道了。 项目Demo下载 http://download.csdn.net/download/weimeig/10161093","categories":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Android/"}]},{"title":"Android第三方登录集成","slug":"AndroidThirdLogin","date":"2014-03-16T19:40:19.000Z","updated":"2018-03-18T03:56:07.999Z","comments":true,"path":"2014/03/17/AndroidThirdLogin/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2014/03/17/AndroidThirdLogin/","excerpt":"","text":"原CSDN博客已弃用，文章会逐渐迁移过来。 转帖请注明本文出自weimeig的博客（http://blog.csdn.net/weimeig/article/details/78818085）， 请尊重他人的辛勤劳动成果，谢谢 ShareSDK集成 一、集成 二、第三方开发平台注册 三、项目中使用 一、集成 到mob.com下载ShareSDK，选择要集成的功能并下载，下载好后，解压，并点击QuickIntegrater.rar生成需要功能，得到Sample文件夹，生成时候记得填写项目包名才点击生成，不然会报错。 （1）将Sample文件夹的libs文件夹里的jar包复制到项目下的app文件夹下的libs文件夹内。 （2）res文件夹内的文件，不做任何改名更改，复制到项目下的app文件夹下的res文件夹内。 （3）将ShareSDK.xml文件复制到项目下的app文件夹下的src下的main文件夹下的assets文件夹中，如果没有这个文件夹则创建一个。 （4）将src文件夹内复制到项目下的app文件夹下的src下的main文件夹下的java文件夹中，与自己原包名项目并列。 （5）更改AndroidManifest.xml文件内应用权限，照着官方文档填写即可，或者下载本文提供的demo，从demo中复制AndroidManifest.xml文件内权限到自己的项目 ( 6 )AndroidManifest.xml文件内设置您从Mob开发者后台中得到的Appkey和AppSecret，如 此时如果有地方报红，点击AndroidStudio上方工具栏里的BuiId下的Clean Project ，结束后点击RebuiId Project,然后再点击一下这个按钮， 原因是新引入的包需要同步一下，就不报红了。 集成完成。 二、第三方开发平台注册 如需要集成第三方登录是QQ、微信、微博。则分别到对应的第三方开放平台注册账号，如微信是微信第三方开放平台，在平台选择开启登录功能，然后填写完应用相关信息后，得到AppId和AppSecret将两者保存下来，一会第三步要用到。这里需要注意的是，平台填写的应用信息中，包名和应用签名，要和app对应。最后面附上怎么查看应用签名的方法。 特别注明：新浪微博的话，还需要在开放平台里选择回调接口地址，在开放平台应用信息附近找到OAuth2.0 授权设置编辑，设置微博回调地址。 比如官方默认的回调地址（默认的也可以使用）： 授权回调页：http://sns.whalecloud.com/sina2/callback取消授权回调页：http://sns.whalecloud.com/sina2/callback 三、项目中使用 （1）将你在第三方开发平台申请到的AppId和AppSecret填写到src下的main文件夹下的assets文件夹内的ShareSDK.xml文件中，替换掉mob提供的初始的。微博的话，还需要在这个文件里面的微博的配置里，设置RedirectUrl这个参数，微博官方默认的是 RedirectUrl=”http://sns.whalecloud.com/sina2/callback&quot; 如果你申请开发平台时用了默认的，可以设置为这个 （2）第三方登录的方法 `/** * 第三方登录方法 * Created by weimei on 2017/12/16. * Email:ucvs@qq.com */ private void thirdLogin(String platformName,final String backType) { Platform wechat = ShareSDK.getPlatform(platformName); wechat.SSOSetting(false); //设置false表示使用SSO授权方式 if(wechat.isAuthValid()){ wechat.removeAccount(true); } wechat.setPlatformActionListener(new PlatformActionListener() { @Override public void onComplete(Platform platform, int i, HashMap&lt;String, Object&gt; hashMap) { Log.d(TAG, &quot;onComplete: &quot;+i+new Gson().toJson(hashMap)); if (i == Platform.ACTION_USER_INFOR) { final PlatformDb platDB = platform.getDb();//获取数平台数据DB //通过DB获取各种数据 platDB.getToken(); platDB.getUserGender(); platDB.getUserIcon(); platDB.getUserId(); platDB.getUserName(); Log.d(TAG, &quot;onComplete: &quot;+ platDB.getToken()+&quot;-&quot;+ platDB.getUserId()+&quot;-&quot;+ platDB.getUserName()); runOnUiThread(new Runnable() { @Override public void run() { // platDB.getUserId()是唯一的 //这里写你的业务逻辑，如网络请求 // mPresenter.trilateralLogin(backType,platDB.getUserId(),platDB.getUserName(), // platDB.getUserIcon(),platDB.getUserGender(),LoginActivity.this); } }); } } @Override public void onError(Platform platform, int i, Throwable throwable) { Log.d(TAG, &quot;onError: &quot;+throwable.toString()); } @Override public void onCancel(Platform platform, int i) { /** * 给用户取消的提示 */ } }); // 设置分享事件回调 wechat.authorize();//单独授权 wechat.showUser(null); }` 然后在需要使用第三方登录的地方调用该方法即可 如果此时报红，则用第一步教的那个方法，同步一下，就不报红了。 此时 QQ调用时，如： thirdLogin(QQ.NAME,&quot;AndroidQQ&quot;); 微信调用时，如： thirdLogin(Wechat.NAME,&quot;AndroidWechat&quot;); 微博调用时，如： thirdLogin(SinaWeibo.NAME,&quot;Androidweibo&quot;); 其中第一个参数的，如：QQ.NAME，是第三方规定的，不可随意更改，第二个参数，是来源，如果你后台的url不需要这个参数，直接删除即可，同时也在thirdLogin方法里面删除即可。 附：查看应用签名的方法。 用密钥打包apk，打包的时候，选择生成release版本，切记不要生成debug版本。然后安装到手机中。 同时安装下面提供的这个apk。打开这个apk，输入你的应用包名，点击生成，生成的这个就是你的安卓签名。 注意这个是要用你发布app的那个密钥去生成apk，并且输入的包名和你发布的app的包名一致，满足这两个要求前提下，才能生成一致的安卓签名。 安卓签名生成软件 http://download.csdn.net/download/weimeig/10161075 项目Demo下载 http://download.csdn.net/download/weimeig/10161093","categories":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Android/"}]}]}