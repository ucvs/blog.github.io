{"meta":{"title":"欢迎来到唯美的网站","subtitle":null,"description":"weimei","author":"Aestheticism","url":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848"},"pages":[{"title":"","date":"2018-03-19T17:31:42.178Z","updated":"2018-03-19T17:31:42.178Z","comments":true,"path":"404.html","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/404.html","excerpt":"","text":"The page you are requesting does not exist!"},{"title":"关于唯美","date":"2013-01-18T00:26:01.000Z","updated":"2018-03-19T11:33:20.877Z","comments":true,"path":"about/index.html","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/about/index.html","excerpt":"","text":""},{"title":"留言板","date":"2014-03-19T12:43:47.000Z","updated":"2018-03-19T13:28:37.335Z","comments":true,"path":"message/index.html","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/message/index.html","excerpt":"","text":"欢迎您来到留言板，但我们更鼓励您去“关于我”板块下面留言"},{"title":"categories","date":"2018-03-16T20:52:19.000Z","updated":"2018-03-16T21:03:16.114Z","comments":false,"path":"categories/index.html","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/index.html","excerpt":"","text":""},{"title":"search","date":"2018-03-15T22:37:50.000Z","updated":"2018-03-15T22:37:50.611Z","comments":true,"path":"search/index-1.html","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/search/index-1.html","excerpt":"","text":""},{"title":"search","date":"2018-03-15T23:35:07.000Z","updated":"2018-03-15T23:35:07.638Z","comments":true,"path":"search/index-2.html","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/search/index-2.html","excerpt":"","text":""},{"title":"search","date":"2018-03-16T08:03:35.000Z","updated":"2018-03-16T08:03:35.042Z","comments":true,"path":"search/index-3.html","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/search/index-3.html","excerpt":"","text":""},{"title":"search","date":"2018-03-15T22:31:29.000Z","updated":"2018-03-15T22:31:29.882Z","comments":true,"path":"search/index.html","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/search/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-03-16T20:56:45.000Z","updated":"2018-03-16T20:56:45.814Z","comments":true,"path":"tags/index.html","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JAVA中的泛型","slug":"Java-Genericity","date":"2015-05-17T10:53:37.000Z","updated":"2018-03-19T10:58:20.387Z","comments":true,"path":"2015/05/17/Java-Genericity/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2015/05/17/Java-Genericity/","excerpt":"","text":"原CSDN博客已弃用，文章会逐渐迁移过来。 转帖请注明本文出自weimeig的博客（http://blog.csdn.net/weimeig/article/details/79535182），请尊重他人的辛勤劳动成果，谢谢 应朋友们反馈的JAVA基础薄弱的问题，决定出一套完整的JAVA基础教程，帮助大家复习，巩固JAVA基础，今天要讲的是JAVA中的泛型。 本篇文章基于http://blog.csdn.net/weimeig/article/details/79533661知识的基础上，请先学前面这篇文章。 泛型 集合中的元素，可以是任意类型的对象（对象的引用） 如果把某个对象放入集合，则会忽略他的类型，而把他当作Object处理 泛型则是规定了某个集合只可以存放特定类型的对象 会在编译期间进行类型检查 可以直接按指定类型获取集合元素 /** * 学生类 * @author Administrator * */ public class Student { private String id; private String name; private Set course; private Student(String id,String name){ this.id = id; this.name = name; this.course = new HashSet(); } public String getId() { return id; } public void setId(String id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Set getCourse() { return course; } public void setCourse(Set course) { this.course = course; } } /** * 课程类 * @author Administrator * */ public class Course { private String id; private String name; Course(){ } Course(String id,String name){ this.id=id; this.name=name; } public String getId() { return id; } public void setId(String id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } } import java.util.ArrayList; import java.util.List; public class TestGeneric { /** * 带有泛型——Course,的List类型属性 */ public List&lt;Course&gt; courses; //&lt;&gt;内限制了数据的类型 //创建构造器实例化 public TestGeneric(){ //构造方法 this.courses = new ArrayList&lt;Course&gt;(); } /** * 测试添加 */ public void testAdd(){ Course cr1 = new Course(&quot;1&quot;,&quot;大学英语&quot;); courses.add(cr1); //泛型集合中，不能添加泛型规定的类型及其子类型以外的对象，否则会报错 // courses.add(&quot;能否添加一些奇怪的东西呢？&quot;); Course cr2 = new Course(&quot;2&quot;, &quot;Java基础&quot;); courses.add(cr2); } public void testForEach(){ for(Course cr:courses){//因为规定了是Course的类型，所以直接作为Course类型取出来，不再需要作为Object类型的转换。 System.out.println(cr.getId() + &quot;:&quot; +cr.getName()); } } public static void main(String[] args){ TestGeneric tg =new TestGeneric(); tg.testAdd(); tg.testForEach(); } } 泛型集合可以添加泛型的子类型的对象实例 创建ChildCourse类，继承Course类 public class ChildCourse extends Course {//ChildCourse继承了Course类型，如果Course类里已经添加了含参的构造器， //编译器将不会自动为他再添加一个隐式构造器，而子类又必须要调用父类的隐式构造器，因此会报错，所以需要在父类中手动定义一个的无参的隐式构造器 // 不添加属性让他默认继承父类的属性 } 在TestGeneric类中添加方法 /** * 泛型集合可以添加泛型的子类型的对象实例 * @param args */ public void testChild(){ ChildCourse ccr = new ChildCourse(); ccr.setId(&quot;3&quot;); ccr.setName(&quot;我是子类型的课程对象实例～～&quot;); courses.add(ccr); } main函数中调用 TestGeneric tg =new TestGeneric(); tg.testChild(); tg.testForEach(); 1、泛型集合中的限定类型，不能使用基本数据类型。2、可以通过使用包装类限定允许存入的基本数据类型 /** * 泛型不能使用基本类型 * @param args */ public void testBasicType(){ / List&lt;int&gt; list = new ArrayList&lt;int&gt;();//使用基本类型报错 List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();//使用包装类 list.add(1);//将1转化为了基本类型的包装类Integer System.out.println(&quot;基本类型必须使用包装类作为泛型！&quot; + list.get(0)); } main函数中调用 TestGeneric tg =new TestGeneric(); tg.testBasicType();","categories":[{"name":"Java","slug":"Java","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Java/"}]},{"title":"JAVA中的集合框架（Map&HashMap）","slug":"Java-Map-HashMap","date":"2015-04-29T10:55:24.000Z","updated":"2018-03-19T11:05:48.726Z","comments":true,"path":"2015/04/29/Java-Map-HashMap/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2015/04/29/Java-Map-HashMap/","excerpt":"","text":"原CSDN博客已弃用，文章会逐渐迁移过来。 转帖请注明本文出自weimeig的博客（http://blog.csdn.net/weimeig/article/details/79575842），请尊重他人的辛勤劳动成果，谢谢 应朋友们反馈的JAVA基础薄弱的问题，决定出一套完整的JAVA基础教程，帮助大家复习，巩固JAVA基础，今天要讲的是JAVA中的Map&amp;HashMap集合。 import java.util.HashSet; import java.util.Set; /** * 学生类 * @author Administrator * */ public class Student { private String id; private String name; private Set&lt;Course&gt; course; Student(String id,String name){ this.id = id; this.name = name; this.course = new HashSet&lt;Course&gt;(); } public String getId() { return id; } public void setId(String id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Set getCourse() { return course; } public void setCourse(Set course) { this.course = course; } public Student get(String stuId) { // TODO Auto-generated method stub return null; } } import java.util.HashMap; import java.util.Map; import java.util.Map.Entry; import java.util.Scanner; import java.util.Set; public class MapTest { /** * 用来承装学生类型对象 */ public Map&lt;String,Student&gt; students; /** * 在构造器中初始化student属性 */ public MapTest(){ this.students = new HashMap&lt;String, Student&gt;(); } /** * 测试添加：输入学生ID.判断时候被占用 * 若未被占用，则输入姓名，创建新学生对象，并且 * 添加到students中 * @param args */ public void testPut(){ //创建一个Scanner对象，用来获取输入的学生ID和姓名 Scanner console = new Scanner(System.in); int i = 0; while(i &lt; 3){ System.out.println(&quot;请输入学生ID：&quot;); String ID = console.next(); //提示输入学生姓名 Student st = students.get(ID); if(st == null){ //提示输入学生姓名 System.out.println(&quot;请输入学生姓名：&quot;); String name = console.next(); //创建新的学生对象 Student newStudent = new Student(ID,name); //通过调用students的put方法，添加ID-学生映射 students.put(ID, newStudent); System.out.println(&quot;成功添加学生：&quot; + students.get(ID).getName()); i++; }else{ System.out.println(&quot;该学生ID已被占用！&quot;); } } } /** * 测试Map的KeySet方法 * @param args */ public void testKeySet(){ //通过KeySet方法，返回Map中的所有&quot;键&quot;的Set集合 Set&lt;String&gt; KeySet = students.keySet(); //遍历KeySet，取得每一个键，再调用get方法取得每个键对于的value //取得student的容量 System.out.println(&quot;总共有&quot; + students.size() + &quot;个学生&quot;); for(String stuId:KeySet){ Student st = students.get(stuId); if(st!=null){ System.out.println(&quot;学生&quot; + st.getName()); } } } /** * 测试删除Map中的映射 * @param args */ public void testRemove(){ //获取从键盘输入的待删除学生ID字符串 Scanner console = new Scanner(System.in); while (true) { //提示输入待删除的学生的ID System.out.println(&quot;请输入要删除的学生ID&quot;); String ID =console.next(); //判断该ID是否有对应的学生对象 Student st = students.get(ID); if(st == null){ //提示输入的ID并不存在 System.out.println(&quot;该ID不存在&quot;); continue; } students.remove(ID); System.out.println(&quot;成功删除学生：&quot; + st.getName()); break; } } /** * 通过entrySet方法来遍历Map * @param args */ public void testEntrySet(){ //通过enterSet方法，返回Map中所有键值对的集合，KeySet只是返回所有键的集合，EntrySet是返回所有键值对的集合 // Set&lt;Entry&gt; entrySet = student.entrySet();//会报错，因为entrySet返回的是entry的集合，而entry本身是带有和定义Map类型的泛型一样的泛型 Set&lt;Entry&lt;String,Student&gt;&gt; entrySet = students.entrySet();//所以要为他定义和当时定义的Map类型一样的数据类型 for(Entry&lt;String,Student&gt; entry:entrySet){ System.out.println(&quot;取得键：&quot; + entry.getKey()); System.out.println(&quot;对应的值为：&quot; + entry.getValue().getName()); } } /** * 利用put方法修改Map中的已有映射 * @param args */ public void testModify(){ //提示输入要修改的学生ID System.out.println(&quot;请输入要修改的学生ID：&quot;); //创建一个Scanner对象，去获取从键盘上输入的学生ID字符串 Scanner console = new Scanner(System.in); while (true) { //取得从键盘输入的学生ID String stuId = console.next(); //从student中查找该学生ID对应的学生对象 Student student = students.get(stuId); if(student == null){ System.out.println(&quot;该ID不存在！请重新输入！&quot;); continue; } //提示当前对应的学生对象的姓名 System.out.println(&quot;当前该学生ID，所对应的学生为&quot; + student.getName()); //提示输入新的学生姓名，来修改已有的映射 System.out.println(&quot;请输入新的学生姓名：&quot;); String name = console.next(); Student newStudent = new Student(stuId, name); students.put(stuId, newStudent); System.out.println(&quot;修改成功！&quot;); break; } } public static void main(String[] args){ MapTest mt =new MapTest(); mt.testPut();//增加 mt.testKeySet();//遍历所有的键 // mt.testRemove();//删除 // mt.testEntrySet();//遍历所有的键和值 mt.testModify();//修改 mt.testEntrySet();//遍历所有的键和值 } }","categories":[{"name":"Java","slug":"Java","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Java/"}]},{"title":"JAVA中的集合框架（Set）","slug":"Java-HashSet","date":"2015-04-28T10:55:09.000Z","updated":"2018-03-19T11:01:15.788Z","comments":true,"path":"2015/04/28/Java-HashSet/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2015/04/28/Java-HashSet/","excerpt":"","text":"原CSDN博客已弃用，文章会逐渐迁移过来。 转帖请注明本文出自weimeig的博客（http://blog.csdn.net/weimeig/article/details/79535273），请尊重他人的辛勤劳动成果，谢谢 应朋友们反馈的JAVA基础薄弱的问题，决定出一套完整的JAVA基础教程，帮助大家复习，巩固JAVA基础，今天要讲的是JAVA中的Set集合。 ArrayList是有序的集合，而Set是无序的集合 有序的集合ArrayList中可以添加多个相同对象（的引用） 而Set中，添加某个对象，无论添加多少次， 最终只会保留一个该对象（的引用） 并且，保留的是第一次添加的那一个 import java.util.HashSet; import java.util.Set; /** * 学生类 * @author Administrator * */ public class Student { private String id; private String name; private Set&lt;Course&gt; course; Student(String id,String name){ this.id = id; this.name = name; this.course = new HashSet&lt;Course&gt;(); } public String getId() { return id; } public void setId(String id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Set getCourse() { return course; } public void setCourse(Set course) { this.course = course; } } /** * 课程类 * @author Administrator * */ public class Course { private String id; private String name; Course(){ } Course(String id,String name){ this.id=id; this.name=name; } public String getId() { return id; } public void setId(String id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } } import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.Scanner; public class SetTest { public List&lt;Course&gt; coursesToSelect; public SetTest(){ this.coursesToSelect = new ArrayList&lt;Course&gt;(); } /** * 用于往coursesToSelect中添加备选课程 */ public void testAdd(){ Course cr1 = new Course(&quot;1&quot;,&quot;数据结构&quot;);//new一个Course类的数据类型 coursesToSelect.add(cr1);//所为一条数据插入List中 Course temp = (Course)coursesToSelect.get(0);//获取LIst中的第一条数据\\ Course cr2 = new Course(&quot;2&quot;,&quot;C语言&quot;); coursesToSelect.add(0, cr2); //两个参数的add方法，选择插入元素的位置 Course temp2 = (Course) coursesToSelect.get(0);//将元素插入到第一条,对象存入集合都变成Object类型，取出时需要类型转换 Course[] course = {new Course(&quot;3&quot;,&quot;离散数学&quot;), new Course(&quot;4&quot;,&quot;汇编语言&quot;)}; coursesToSelect.addAll(Arrays.asList(course)); //添加数组用addAll Course temp3 = (Course) coursesToSelect.get(2); Course temp4 = (Course) coursesToSelect.get(3); //按位置插入 Course[] course2 = {new Course(&quot;5&quot;,&quot;高等数学&quot;),new Course(&quot;6&quot;,&quot;大学英语&quot;)}; coursesToSelect.addAll(2, Arrays.asList(course2)); Course temp5 = (Course)coursesToSelect.get(2); Course temp6 = (Course)coursesToSelect.get(3); } /** * 通过for each方法访问集合元素 * 迭代器的简便写法 * @param args */ public void testForEach(){ System.out.println(&quot;有如下课程可选（通过for each访问）：&quot;); for(Object obj:coursesToSelect){//去遍历coursesToSelect集合中的每一个元素，把它取出来作为Object的一个变量 //（当一个元素存入到集合中的时候，他的类型是被忽略了的，集合只是拿他当Object用），当取出来的时候也是一个Object，因此 Course cr =(Course)obj;//当他取出来后，需要做强转 System.out.println(&quot;课程：&quot; + cr.getId() + &quot;:&quot; + cr.getName()); } } public static void main(String []args){ SetTest st =new SetTest(); st.testAdd(); st.testForEach(); //创建一个学生对象 Student student = new Student(&quot;1&quot;,&quot;小明&quot;); System.out.println(&quot;欢迎学生：&quot; + student.getName() + &quot;选课！&quot;); //创建一个Scanner对象，用来接收从键盘输入的课程ID Scanner console = new Scanner(System.in); for(int i=0;i&lt;3;i++){ System.out.println(&quot;请输入课程ID&quot;); String courseId = console.next(); for(Course cr:st.coursesToSelect){ if(cr.getId().equals(courseId)){ student.getCourse().add(cr); // student.getCourse().add(cr); /** * Set中，添加某个对象，无论添加多少次， * 最终只会保留一个该对象（的引用） * 并且，保留的是第一次添加的那一个 */ // student.getCourse().add(null);Set中是允许添加null空对象的 } } } st.testForEachForSet(student); } public void testForEachForSet(Student student){ //打印输出，学生所选的课程！ System.out.println(&quot;共选择了&quot; + student.getCourse().size() + &quot;门课程&quot;); for(Object obj : student.getCourse()){ Course cr = (Course)obj; System.out.println(&quot;选择了课程：&quot; + cr.getId() + &quot;:&quot; +cr.getName()); } } }","categories":[{"name":"Java","slug":"Java","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Java/"}]},{"title":"多线程的经典案例(生产消费问题)","slug":"MiltiCaseProduConsum","date":"2015-04-27T10:45:21.000Z","updated":"2018-03-19T10:52:23.469Z","comments":true,"path":"2015/04/27/MiltiCaseProduConsum/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2015/04/27/MiltiCaseProduConsum/","excerpt":"","text":"原CSDN博客已弃用，文章会逐渐迁移过来。 多线程的经典案例(生产消费问题) 未完待续。。","categories":[{"name":"Java","slug":"Java","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Java/"}]},{"title":"Multithreading","slug":"Multithreading","date":"2015-04-23T10:18:36.000Z","updated":"2018-03-19T10:51:59.969Z","comments":true,"path":"2015/04/23/Multithreading/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2015/04/23/Multithreading/","excerpt":"","text":"原CSDN博客已弃用，文章会逐渐迁移过来。 转帖请注明本文出自weimeig的博客（http://blog.csdn.net/weimeig/article/details/79510581），请尊重他人的辛勤劳动成果，谢谢 应朋友们反馈的JAVA基础薄弱的问题，决定出一套完整的JAVA基础教程，帮助大家复习，巩固JAVA基础，今天要讲的是多线程。 创建线程的第一种方法，创建线程的类。 class Xc extends Thread{//创建线程所需要继承的类 public void run(){//run方法是覆盖的父类方法 for(int i=0;i&lt;100;i++){ System.out.println(&quot;子线程&quot;); } } } public class XianCheng { public static void main(String [] args){ new Xc().start();//谁调Start方法，就会去自动调用run方法 for(int i=0;i&lt;100;i++){ System.out.println(&quot;主线程&quot;); } } } 创建线程的第二种方法，实现线程的接口。 class Xc2 implements Runnable{ public void run(){ for(int i=0;i&lt;100;i++){ System.out.println(&quot;子线程&quot;); } } } public class XianCheng { public static void main(String [] args){ new Thread(new Xc2()).start(); for(int i=0;i&lt;100;i++){ System.out.println(&quot;主线程&quot;); } } } 创建线程的第三种方法，简约写法。 public class XianCheng { public static void main(String [] args){ new Thread(){ public void run(){ for(int i=0;i&lt;100;i++){ System.out.println(&quot;子线程&quot;); } } }.start(); for(int i=0;i&lt;100;i++){ System.out.println(&quot;主线程&quot;); } } } 创建线程的第四种方法，简约写法。 public class XianCheng { public static void main(String [] args){ new Runnable() { public void run() { for(int i=0;i&lt;30;i++){ System.out.println(&quot;我是子线程！！！&quot;); } } }.run(); for(int i=0;i&lt;30;i++){ System.out.println(&quot;主线程&quot;); } } } 观察线程的竞争 class Xc3 extends Thread{ public void run(){ System.out.println(Thread.currentThread().getName()+&quot;线程在运行&quot;); } } public class XianCheng { public static void main(String [] args){ Xc3 xc3 = new Xc3(); xc3.setName(&quot;线程3&quot;); xc3.start(); Xc3 xc31 = new Xc3(); xc31.setName(&quot;线程2&quot;); xc31.start(); Xc3 xc32 = new Xc3(); xc32.setName(&quot;线程3&quot;); xc32.start(); System.out.println(Thread.currentThread().getName()+&quot;线程在运行&quot;); } } 线程的优先级 static int MAX_PRIORITY = 10;//线程可以具有的最高优先级（执行概率最高） static int MIN_PRIORITY = 1; //线程可以具有的最低优先级（执行概率最低） static int NORM_PRIORITY = 5；//分配给线程的默认优先级 写法（1） class Xc extends Thread{ public void run(){ System.out.println(&quot;线程1在运行&quot;); } } public class XianCheng { public static void main(String [] args){ Xc xc = new Xc();//线程默认优先级是5 xc.setPriority(Thread.NORM_PRIORITY + 3);//数字越大优先级越高 xc.start(); new Thread(){ public void run(){ System.out.println(&quot;第二个线程正在被执行&quot;); } }.start(); } } 写法（2） public class XianCheng { public static void main(String [] args){ new Thread(){ public void run(){//线程默认优先级是5 setPriority(Thread.NORM_PRIORITY + 3);//数字越大优先级越高 System.out.println(&quot;第1个线程&quot;); } }.start(); new Thread(){ public void run(){ System.out.println(&quot;第二个线程正在被执行&quot;); } }.start(); } } 线程的睡眠 public class XianCheng { public static void main(String [] args){ new Thread(){ public void run(){ for(int i=0;i&lt;10;i++){ System.out.println(Thread.currentThread().getName() + &quot; &quot; + i); try { Thread.sleep(1000);//1000毫秒等于一秒 } catch (Exception e) { // TODO: handle exception } } } }.start(); } } 线程的抛异常问题，举例 都是会报错的，因为用throws抛异常的时候，如果向主调处抛异常的方法是从父类继承的或者是从接口实现的那么，覆盖父类的方法或实现接口方法时，如果父类中的原方法或接口中的原抽象方法没有抛异常，则子类覆盖父类的方法或实现接口的方法也不能抛异常。 class Yy implements Runnable{ public void run() throws Exception { } } class Xx extends Thread{ public void run() throws Exception { } } 当出现这种情况只能try…catch，大不了catch中什么都不写。 线程的让步 public class XianCheng { public static void main(String [] args){ new Thread(){ public void run(){ setName(&quot;线程一：&quot;); for(int i=1;i&lt;=30;i++){ System.out.println(Thread.currentThread().getName() + i); } } }.start(); new Thread(){ public void run(){ setName(&quot;线程二：&quot;); for(int i=1;i&lt;=30;i++){ System.out.println(Thread.currentThread().getName() + i); if(i%5==0){ Thread.yield(); //线程让步出去让其他线程先执行，再次执行时，从让步的这个位置重新执行。 } } } }.start(); } } 线程的阻塞 class Xc implements Runnable{ public void run(){ for(int i=0;i&lt;30;i++){ System.out.println(&quot;子线程&quot; + i); } } } public class XianCheng { public static void main(String [] args){ Thread xc = new Thread(new Xc()); xc.start(); try { xc.join();//阻塞时将当前线程暂停，直至调用join函数所对应的线程执行完毕，才继续执行程序。 //也就是说，当执行到这里，当前执行线程就暂停了，而去执行join所对应的xc这个线程，直到xc这个线程执行完毕才回来，此时线程们重新竞争CPU。 } catch (Exception e) { // TODO: handle exception } for(int i=0;i&lt;30;i++){ System.out.println(&quot;主线程&quot; + i); } } }","categories":[{"name":"Java","slug":"Java","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Java/"}]},{"title":"Interface","slug":"Interface","date":"2015-04-20T10:16:45.000Z","updated":"2018-03-19T10:52:53.457Z","comments":true,"path":"2015/04/20/Interface/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2015/04/20/Interface/","excerpt":"","text":"原CSDN博客已弃用，文章会逐渐迁移过来。 转帖请注明本文出自weimeig的博客（http://blog.csdn.net/weimeig/article/details/79501228），请尊重他人的辛勤劳动成果，谢谢 应朋友们反馈的JAVA基础薄弱的问题，决定出一套完整的JAVA基础教程，帮助大家复习，巩固JAVA基础，今天要讲的是接口。 /** *接口：初步理解，接口是一个特殊的抽象类，当抽象类中全部是抽象方法时 *可以通过接口的形式来体现。 *class 用于定义类 *interface 用于定义接口 * * 接口中成员的格式： * 1.public static final String NAME=&quot;小李&quot;;//全局常量 * 2.public abstract void show();//抽象方法 * * 注意： * 1.接口中只能出现public 访问修饰符 * 2.接口不可以创建对象，因为里面有抽象方法，需要被子类实现， * 子类对接口中的所有抽象方法实现后，子类才能够实例化，否则 * 子类就是一个抽象类 * * 关系： * 类与类之间：继承关系 * 接口与类之间：实现关系 * 接口与接口之间：继承关系 * 接口与接口之间：不具备实现关系 */ interface smoket{ public static final String NAME=&quot;小李&quot;; public abstract void show(); } interface Game{ //inrerface Game extends Smoket{ //这句实现Game接口等同于实现了Game与Smoket //两个接口，需要实现两个的方法 public abstract void computerGame(); } class Student implements smoket,Game{ @Override public void show() { // TODO Auto-generated method stub System.out.println(&quot;吸烟&quot;); } @Override public void computerGame() { // TODO Auto-generated method stub System.out.println(&quot;游戏&quot;); } } public class jiekou { public static void main(String[] args){ Student s=new Student(); s.show(); s.computerGame(); } }","categories":[{"name":"Java","slug":"Java","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Java/"}]},{"title":"多线程的经典案例(卖票问题)","slug":"MultiCaseTicket","date":"2015-04-16T10:40:16.000Z","updated":"2018-03-19T10:52:11.549Z","comments":true,"path":"2015/04/16/MultiCaseTicket/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2015/04/16/MultiCaseTicket/","excerpt":"","text":"原CSDN博客已弃用，文章会逐渐迁移过来。 转帖请注明本文出自weimeig的博客（http://blog.csdn.net/weimeig/article/details/79512965），请尊重他人的辛勤劳动成果，谢谢 应朋友们反馈的JAVA基础薄弱的问题，决定出一套完整的JAVA基础教程，帮助大家复习，巩固JAVA基础，今天要讲的是多线程的经典案例。 卖票问题 class Xc implements Runnable{ public int chepiao = 100; public void run(){ while (true) { if(chepiao&gt;0){ System.out.println(&quot;第&quot; + Thread.currentThread().getName() + &quot;个车站正在卖出第&quot; + (101-chepiao) + &quot;张车票&quot;); --chepiao; }else{ break; } } } } public class XianCheng { public static void main(String [] args){ Thread Xc1 = new Thread(new Xc());//模拟两个车站在卖车票，竞争共同的线程资源 Xc1.start(); Thread Xc2 = new Thread(new Xc());//模拟两个车站在卖车票，竞争共同的线程资源 Xc2.start(); } } 通过代码，我们不难发现，在运行的过程中出现了错误，因为Xc1和Xc2各自都生成了100张车票，而车票没有共享，此时，我们需要将车票定义为静态变量，使得两线程在竞争售票的过程中，共享车票，于是，将常量定义为静态常量，用static修饰： public static int chepiao = 100; class Xc implements Runnable{ public static int chepiao = 100; public void run(){ while (true) { if(chepiao&gt;0){ System.out.println(&quot;第&quot; + Thread.currentThread().getName() + &quot;个车站正在卖出第&quot; + (101-chepiao) + &quot;张车票&quot;); --chepiao; }else{ break; } } } } public class XianCheng { public static void main(String [] args){ Thread Xc1 = new Thread(new Xc());//模拟两个车站在卖车票，竞争共同的线程资源 Xc1.start(); Thread Xc2 = new Thread(new Xc());//模拟两个车站在卖车票，竞争共同的线程资源 Xc2.start(); } } 但是很快的，我们又发现了新问题，因为线程在竞争的过程中，CPU的切换是非常快的，可能线程1正好执行完–maipiao的时候，线程已经切换到了线程2，此时–maipiao又再执行了一次，导致跳过了一张票没有卖出，或者，当线程1恰好正好将要执行–maipiao但还没执行的时候，线程已经切换到了线程2，此时因为线程1并没有进行–maipiao操作，线程2卖出了重复的同一张票以后，才执行了–maipiao，导致出现了同一张票重复销售的情况。 此时，我们需要引入线程锁的概念，以解决线程的同步问题。 第一种写法： class Xc implements Runnable{ public static int chepiao = 100; //synchronized的作用是，让它所管辖的代码部分，要么全部执行完，要么全部不执行，synchronized既可修饰代码块，又可以修饰函数 // 如果是锁整个方法，可以在方法内加锁，表达上比如public synchronized void run(){，但对于此案例，是两个线程之间竞争售票，因此不适宜锁起来整个方法 //如果synchronized是锁起来整个方法的，synchronized修饰函数不需要传入字符串参数，相当于默认是this public void run(){ while (true) { synchronized (&quot; &quot;) {//在需要加锁保证完整运行的代码块旁边加上synchronized (&quot; &quot;){}包裹代码，即可锁起来该部分代码，()内的字符串随意定义 if(chepiao&gt;0){ System.out.println(&quot;第&quot; + Thread.currentThread().getName() + &quot;个车站正在卖出第&quot; + (101-chepiao) + &quot;张车票&quot;); --chepiao; }else{ break; } } } } } public class XianCheng { public static void main(String [] args){ Thread Xc1 = new Thread(new Xc());//模拟两个车站在卖车票，竞争共同的线程资源 Xc1.start(); Thread Xc2 = new Thread(new Xc());//模拟两个车站在卖车票，竞争共同的线程资源 Xc2.start(); } } 第二种写法： class Xc implements Runnable{ public static int chepiao = 100; public static String str = new String(&quot;weimeig&quot;);//提取出来提高可维护性，同时定义为static静态变量，使得str是公共的 //如果不定义成static静态，则两个线程各自有各自的str，那么大家竞争的就不是同一个资源 public void run(){ while (true) { synchronized (str) {//若不定义为static静态，则两个线程的str是线程自己的，而不是公共的，因为这种写法，初始化的str写在了锁的外面 if(chepiao&gt;0){ System.out.println(&quot;第&quot; + Thread.currentThread().getName() + &quot;个车站正在卖出第&quot; + (101-chepiao) + &quot;张车票&quot;); --chepiao; }else{ break; } } } } } public class XianCheng { public static void main(String [] args){ Thread Xc1 = new Thread(new Xc());//模拟两个车站在卖车票，竞争共同的线程资源 Xc1.start(); Thread Xc2 = new Thread(new Xc());//模拟两个车站在卖车票，竞争共同的线程资源 Xc2.start(); } }","categories":[{"name":"Java","slug":"Java","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Java/"}]},{"title":"JAVA中的集合框架（ArrayList）","slug":"Java-ArrayList","date":"2015-04-13T10:46:56.000Z","updated":"2018-03-19T11:06:09.360Z","comments":true,"path":"2015/04/13/Java-ArrayList/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2015/04/13/Java-ArrayList/","excerpt":"","text":"原CSDN博客已弃用，文章会逐渐迁移过来。 转帖请注明本文出自weimeig的博客（http://mp.blog.csdn.net/postedit/79533661），请尊重他人的辛勤劳动成果，谢谢 应朋友们反馈的JAVA基础薄弱的问题，决定出一套完整的JAVA基础教程，帮助大家复习，巩固JAVA基础，今天要讲的是JAVA中的集合框架。 /** * 学生类 * @author Administrator * */ public class Student { private String id; private String name; private Set course; private Student(String id,String name){ this.id = id; this.name = name; this.course = new HashSet(); } public String getId() { return id; } public void setId(String id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Set getCourse() { return course; } public void setCourse(Set course) { this.course = course; } } /** * 课程类 * @author Administrator * */ public class Course { private String id; private String name; Course(String id,String name){ this.id=id; this.name=name; } public String getId() { return id; } public void setId(String id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } } 单个元素的插入 import java.util.ArrayList; import java.util.List; /** * 备选课程类 * @author Administrator * */ public class ListTest { /** * 用于存放备选课程的List */ public List coursesToSelect; public ListTest(){ this.coursesToSelect = new ArrayList(); } /** * 用于往coursesToSelect中添加备选课程 */ public void testAdd(){ Course cr1 = new Course(&quot;1&quot;,&quot;数据结构&quot;);//new一个Course类的数据类型 coursesToSelect.add(cr1);//所为一条数据插入List中 Course temp = (Course)coursesToSelect.get(0);//获取LIst中的第一条数据，课程存入集合都变成Object类型，取出时需要类型转换 System.out.println(&quot;添加了课程：&quot; + temp.getId() + temp.getName()); } public static void main(String [] args) { ListTest lt = new ListTest(); lt.testAdd(); } } 多个元素的同时插入数组的集合插入，由单个元素的add方法，变成addAll方法 import java.util.ArrayList; import java.util.Arrays; import java.util.List; /** * 备选课程类 * @author Administrator * */ public class ListTest { /** * 用于存放备选课程的List */ public List coursesToSelect; public ListTest(){ this.coursesToSelect = new ArrayList(); } /** * 用于往coursesToSelect中添加备选课程 */ public void testAdd(){ Course cr1 = new Course(&quot;1&quot;,&quot;数据结构&quot;);//new一个Course类的数据类型 coursesToSelect.add(cr1);//所为一条数据插入List中 Course temp = (Course)coursesToSelect.get(0);//获取LIst中的第一条数据 System.out.println(&quot;添加了课程：&quot; + temp.getId() + &quot;:&quot; + temp.getName()); Course cr2 = new Course(&quot;2&quot;,&quot;C语言&quot;); coursesToSelect.add(0, cr2); //两个参数的add方法，选择插入元素的位置 Course temp2 = (Course) coursesToSelect.get(0);//将元素插入到第一条 System.out.println(&quot;添加了课程：&quot; + temp2.getId() + &quot;:&quot; + temp2.getName());//观察打印的第一条的值 // 以下方法会抛出数组下标越界异常 // Course cr3 = new Course(&quot;3&quot;,&quot;test&quot;); // coursesToSelect.add(4, cr3); //插入位置大于容量，数组下标越界 /** * 多个元素的同时插入 */ Course[] course = {new Course(&quot;3&quot;,&quot;离散数学&quot;), new Course(&quot;4&quot;,&quot;汇编语言&quot;)}; coursesToSelect.addAll(Arrays.asList(course)); //添加数组用addAll Course temp3 = (Course) coursesToSelect.get(2); Course temp4 = (Course) coursesToSelect.get(3); System.out.println(&quot;添加了两门课程：&quot; + temp3.getId() + &quot;:&quot; + temp3.getName() + &quot;;&quot; + temp4.getId() + &quot;:&quot; + temp4.getName()); //按位置插入 Course[] course2 = {new Course(&quot;5&quot;,&quot;高等数学&quot;),new Course(&quot;6&quot;,&quot;大学英语&quot;)}; coursesToSelect.addAll(2, Arrays.asList(course2)); Course temp5 = (Course)coursesToSelect.get(2); Course temp6 = (Course)coursesToSelect.get(3); System.out.println(&quot;添加了两门课程：&quot; + temp5.getId() + &quot;:&quot; + temp5.getName() + &quot;;&quot; + temp6.getId() + &quot;:&quot; + temp6.getName()); } public static void main(String [] args) { ListTest lt = new ListTest(); lt.testAdd(); } } 查询元素的三种写法 /** * 取得List中的元素的方法 * @param args */ public void testGet(){ int size = coursesToSelect.size();//创建一个Size变量用来接收Lisr的长度 System.out.println(&quot;有如下课程可选：&quot;); for(int i=0;i&lt;coursesToSelect.size();i++){ Course cr = (Course) coursesToSelect.get(i); System.out.println(&quot;课程：&quot; + cr.getId() + &quot;:&quot; + cr.getName()); } } /** * 通过迭代器来遍历List * @param args */ public void testIterator(){ //通过集合的方法，取得迭代器的实例。 Iterator it = coursesToSelect.iterator(); System.out.println(&quot;有如下课程可选（通过迭代器访问）：&quot;); while (it.hasNext()) {//it.hasNext如果含有元素就返回真值 Course cr = (Course)it.next(); System.out.println(&quot;课程：&quot; + cr.getId() + &quot;:&quot; + cr.getName()); } } /** * 通过for each方法访问集合元素 * 迭代器的简便写法 * @param args */ public void testForEach(){ System.out.println(&quot;有如下课程可选（通过for each访问）：&quot;); for(Object obj:coursesToSelect){//去遍历coursesToSelect集合中的每一个元素，把它取出来作为Object的一个变量 //（当一个元素存入到集合中的时候，他的类型是被忽略了的，集合只是拿他当Object用），当取出来的时候也是一个Object，因此 Course cr =(Course)obj;//当他取出来后，需要做强转 System.out.println(&quot;课程：&quot; + cr.getId() + &quot;:&quot; + cr.getName()); } } main函数中调用 ListTest lt = new ListTest(); lt.testGet(); lt.testIterator(); lt.testForEach(); 修改元素 /** * 修改List中的元素 * @param args */ public void testModify(){ coursesToSelect.set(4, new Course(&quot;7&quot;,&quot;毛概&quot;));//设置4位置的元素为：7,毛概 } 删除元素 /** * 删除List中的元素 * @param args */ public void testRemove(){ // Course cr = (Course) coursesToSelect.get(4); // System.out.println(&quot;我是课程：&quot; + cr.getId() + &quot;:&quot; +cr.getName() + &quot;我即将被删除&quot;); // coursesToSelect.remove(cr); System.out.println(&quot;即将删除4位置上的课程！&quot;); coursesToSelect.remove(4); System.out.println(&quot;成功删除课程！&quot;); testForEach();//调用前面写的遍历方法遍历数据 /** * 同时删除多行时 */ // System.out.println(&quot;即将删除4位置和5位置上的课程！&quot;); // Course[] courses = {(Course) coursesToSelect.get(4),(Course) coursesToSelect.get(5)};//新建一个课程的数组将4位置和5位置的元素 // //加入到数组中 // coursesToSelect.removeAll(Arrays.asList(courses));///调用removeAll方法，通过asList工具类，把courses数组转化为集合作为参数传递进去 // testForEach();//调用前面写的遍历方法遍历数据 } main函数中调用 ListTest lt = new ListTest(); lt.testRemove(); 小节ListTest类完整代码 import java.util.ArrayList; import java.util.Arrays; import java.util.Iterator; import java.util.List; /** * 备选课程类 * @author Administrator * */ public class ListTest { /** * 用于存放备选课程的List */ public List coursesToSelect; public ListTest(){ this.coursesToSelect = new ArrayList(); } /** * 用于往coursesToSelect中添加备选课程 */ public void testAdd(){ Course cr1 = new Course(&quot;1&quot;,&quot;数据结构&quot;);//new一个Course类的数据类型 coursesToSelect.add(cr1);//所为一条数据插入List中 Course temp = (Course)coursesToSelect.get(0);//获取LIst中的第一条数据 System.out.println(&quot;添加了课程：&quot; + temp.getId() + &quot;:&quot; + temp.getName()); Course cr2 = new Course(&quot;2&quot;,&quot;C语言&quot;); coursesToSelect.add(0, cr2); //两个参数的add方法，选择插入元素的位置 Course temp2 = (Course) coursesToSelect.get(0);//将元素插入到第一条,对象存入集合都变成Object类型，取出时需要类型转换 System.out.println(&quot;添加了课程：&quot; + temp2.getId() + &quot;:&quot; + temp2.getName());//观察打印的第一条的值 coursesToSelect.add(cr1);//所为一条数据插入List中 Course temp0 = (Course)coursesToSelect.get(2);//获取LIst中的第一条数据 System.out.println(&quot;添加了课程：&quot; + temp0.getId() + &quot;:&quot; + temp0.getName()); // 以下方法会抛出数组下标越界异常 // Course cr3 = new Course(&quot;3&quot;,&quot;test&quot;); // coursesToSelect.add(4, cr3); //插入位置大于容量，数组下标越界 Course[] course = {new Course(&quot;3&quot;,&quot;离散数学&quot;), new Course(&quot;4&quot;,&quot;汇编语言&quot;)}; coursesToSelect.addAll(Arrays.asList(course)); //添加数组用addAll Course temp3 = (Course) coursesToSelect.get(3); Course temp4 = (Course) coursesToSelect.get(4); System.out.println(&quot;添加了两门课程：&quot; + temp3.getId() + &quot;:&quot; + temp3.getName() + &quot;;&quot; + temp4.getId() + &quot;:&quot; + temp4.getName()); //按位置插入 Course[] course2 = {new Course(&quot;5&quot;,&quot;高等数学&quot;),new Course(&quot;6&quot;,&quot;大学英语&quot;)}; coursesToSelect.addAll(2, Arrays.asList(course2)); Course temp5 = (Course)coursesToSelect.get(2); Course temp6 = (Course)coursesToSelect.get(3); System.out.println(&quot;添加了两门课程：&quot; + temp5.getId() + &quot;:&quot; + temp5.getName() + &quot;;&quot; + temp6.getId() + &quot;:&quot; + temp6.getName()); } /** * 取得List中的元素的方法 * @param args */ public void testGet(){ int size = coursesToSelect.size();//创建一个Size变量用来接收Lisr的长度 System.out.println(&quot;有如下课程可选：&quot;); for(int i=0;i&lt;coursesToSelect.size();i++){ Course cr = (Course) coursesToSelect.get(i); System.out.println(&quot;课程：&quot; + cr.getId() + &quot;:&quot; + cr.getName()); } } /** * 通过迭代器来遍历List * @param args */ public void testIterator(){ //通过集合的方法，取得迭代器的实例。 Iterator it = coursesToSelect.iterator(); System.out.println(&quot;有如下课程可选（通过迭代器访问）：&quot;); while (it.hasNext()) {//it.hasNext如果含有元素就返回真值 Course cr = (Course)it.next(); System.out.println(&quot;课程：&quot; + cr.getId() + &quot;:&quot; + cr.getName()); } } /** * 通过for each方法访问集合元素 * 迭代器的简便写法 * @param args */ public void testForEach(){ System.out.println(&quot;有如下课程可选（通过for each访问）：&quot;); for(Object obj:coursesToSelect){//去遍历coursesToSelect集合中的每一个元素，把它取出来作为Object的一个变量 //（当一个元素存入到集合中的时候，他的类型是被忽略了的，集合只是拿他当Object用），当取出来的时候也是一个Object，因此 Course cr =(Course)obj;//当他取出来后，需要做强转 System.out.println(&quot;课程：&quot; + cr.getId() + &quot;:&quot; + cr.getName()); } } /** * 修改List中的元素 * @param args */ public void testModify(){ coursesToSelect.set(4, new Course(&quot;7&quot;,&quot;毛概&quot;));//设置4位置的元素为：7,毛概 } /** * 删除List中的元素 * @param args */ public void testRemove(){ // Course cr = (Course) coursesToSelect.get(4); // System.out.println(&quot;我是课程：&quot; + cr.getId() + &quot;:&quot; +cr.getName() + &quot;我即将被删除&quot;); // coursesToSelect.remove(cr); System.out.println(&quot;即将删除4位置上的课程！&quot;); coursesToSelect.remove(4); System.out.println(&quot;成功删除课程！&quot;); testForEach();//调用前面写的遍历方法遍历数据 /** * 同时删除多行时 */ // System.out.println(&quot;即将删除4位置和5位置上的课程！&quot;); // Course[] courses = {(Course) coursesToSelect.get(4),(Course) coursesToSelect.get(5)};//新建一个课程的数组将4位置和5位置的元素 // //加入到数组中 // coursesToSelect.removeAll(Arrays.asList(courses));///调用removeAll方法，通过asList工具类，把courses数组转化为集合作为参数传递进去 // testForEach();//调用前面写的遍历方法遍历数据 } public static void main(String [] args) { ListTest lt = new ListTest(); lt.testAdd(); lt.testGet(); lt.testIterator(); lt.testForEach(); lt.testModify(); lt.testForEach(); lt.testRemove(); } } 那么，能否向集合中添加一些奇怪的元素呢？ /** * 往集合中添加一些奇怪的东西 * @param args */ public void testType(){ System.out.println(&quot;能否往List中添加一些奇怪的东西呢？&quot;); coursesToSelect.add(&quot;我不是课程，我只是一个无辜的字符串！！&quot;); } 调用 public static void main(String [] args) { ListTest lt = new ListTest(); lt.testAdd(); lt.testType(); lt.testForEach(); } 很明显，抛出了异常。 那么，有没有一种方法可以控制数据的类型呢？ 答案肯定是有的，那就是JAVA中的，泛型 下章泛型学习：http://blog.csdn.net/weimeig/article/details/79535182 伪代码助记 class TestList{ private List&lt;Course&gt; course; //构造函数初始化 public TestList(){ this.course = new ArrayList&lt;Course&gt;(); } //增加 public void add(){ course.add(new Course(&quot;1&quot;,&quot;课程&quot;)); } //删除 public void remove(){ course.remove(1); } //修改 public void set(){ course.set(&quot;1&quot;,new Course(&quot;1&quot;,&quot;课程&quot;)); } //查询 public void ForEach(){ // for(Object obj:course){ // Course cr = (Course)obj; // } for(Course cr:course){} } public static void main(String[] args){} }","categories":[{"name":"Java","slug":"Java","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Java/"}]},{"title":"AbstractClass","slug":"AbstractClass","date":"2015-03-20T10:12:55.000Z","updated":"2018-03-19T10:16:06.671Z","comments":true,"path":"2015/03/20/AbstractClass/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2015/03/20/AbstractClass/","excerpt":"","text":"原CSDN博客已弃用，文章会逐渐迁移过来。 转帖请注明本文出自weimeig的博客（http://blog.csdn.net/weimeig/article/details/79498536），请尊重他人的辛勤劳动成果，谢谢 应朋友们反馈的JAVA基础薄弱的问题，决定出一套完整的JAVA基础教程，帮助大家复习，巩固JAVA基础，今天要讲的是抽象类。 /** *abstract是一个修饰符 *可以修饰方法，类 *1.当我们多个类存在相同的功能时，但是功能的主体不同，这时我们进行向上抽取 *只抽取功能的定义不抽取功能的主体 * * 抽象类的特点： * 1.抽象方法一定要在抽象类中 * 2.抽象类和抽象方法必须要被abstract关键字修饰 * 3.抽象的类是不能被创建对象，因为调用抽象的方法没意义 * 4.抽象类中的方法要被使用，必须由之类重写抽象类中的方法，然后创建之类对象来调用。 * 5.抽象类中可以定义非抽象的方法，有时我们需要此类不能被new关键字创建对象时， * 可以用abstract将此类变成抽象类 * 6.子类如果只重写一部分的抽象方法，那么该子类还是一个抽象类。如果抽象类的方法 * 要被使用，子类必须重写抽象类中的所有方法。 * * 值得注意：抽象类和普通的类没有太大的不同。 * 1.抽象类无法通过new关键字创建对象 * 2.抽象类里面可以有抽象的方法 */ abstract class Animal{ abstract void sing(); void show(){ System.out.println(&quot;你好&quot;); } } class Cat extends Animal{ void sing(){ System.out.println(&quot;喵喵唱歌&quot;); } } class Dog extends Animal{ void sing(){ System.out.println(&quot;汪汪唱歌&quot;); } } public class chouxianglei { public static void main(String[] args) { Animal a=new Dog();//Animal是抽象类不能new对象，但可以接收子类对象 a.sing(); } } 我们不难发现，不同的子类继承父类后，各自有不同的重写需求，那么父类中的方法突然变得没有了意义，这时候，我们可以将父类Animal中的 void show(){ System.out.println(&quot;你好&quot;); } 方法改为看不懂的抽象方法，abstract void sing();此时会报错，因为，抽象方法需要存在抽象类中， 所以，将类定义为abstract class Animal抽象类。当然，方法体中的abstract void sing()不加abstract， 编译的时候是会默认加上去的。","categories":[{"name":"Java","slug":"Java","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Java/"}]},{"title":"toString方法","slug":"Java-toString","date":"2015-03-19T09:40:25.000Z","updated":"2018-03-19T09:45:25.127Z","comments":true,"path":"2015/03/19/Java-toString/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2015/03/19/Java-toString/","excerpt":"","text":"原CSDN博客已弃用，文章会逐渐迁移过来。 转帖请注明本文出自weimeig的博客（http://blog.csdn.net/weimeig/article/details/79497172），请尊重他人的辛勤劳动成果，谢谢 应朋友们反馈的JAVA基础薄弱的问题，决定出一套完整的JAVA基础教程，帮助大家复习，巩固JAVA基础，今天要讲的是toString方法。 public class toStringFangFa { public static void main(String []args){ System.out.println(new String(&quot;你好&quot;)); } } 我们不难发现，在这行代码中，我们找不到字符串的时候，直接new的一个String传你好进去，他可以正常打印运行，因为在java中，我们尽管没有调用toString方法，当他给我们默认的调用了，出现的效果和我们的 public class toStringFangFa { public static void main(String []args){ System.out.println(new String(&quot;你好&quot;).toString()); } } 是一样的。 好了，大家可以继续练习一下。 class Ca{ String name; int avg; public String toString(){ return &quot;我的名字&quot; + name + &quot;,我的年龄&quot; + avg; } } public class toStringFangFa { public static void main(String []args){ Ca ca = new Ca(); ca.name = &quot;张三&quot;; ca.avg = 18; System.out.println(ca); } }","categories":[{"name":"Java","slug":"Java","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Java/"}]},{"title":"OkHttp框架读书总结笔记","slug":"OkHttpReadingNotes","date":"2015-02-11T03:55:21.000Z","updated":"2018-03-18T04:32:48.958Z","comments":true,"path":"2015/02/11/OkHttpReadingNotes/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2015/02/11/OkHttpReadingNotes/","excerpt":"","text":"原CSDN博客已弃用，文章会逐渐迁移过来。 转帖请注明本文出自weimeig的博客（http://blog.csdn.net/weimeig/article/details/78656734），请尊重他人的辛勤劳动成果，谢谢 一、添加依赖 build.gradle dependencies { compile &apos;com.squareup.okhttp3:okhttp:3.2.0&apos; compile &apos;com.squareup.okio:okio:1.7.0&apos; } 权限: &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; HelloOkhttp import java.io.IOException; import okhttp3.OkHttpClient; import okhttp3.Request; import okhttp3.Response; /** * Created by Administrator on 2017/11/27. */ public class HelloOkhttp { public static void main(String [] args) throws IOException { OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder(). url(&quot;http://www.baidu.com&quot;).build(); try { Response response = client.newCall(request).execute(); if (response.isSuccessful()) { System.out.println(response.body().string()); } } catch (IOException e) { e.printStackTrace(); } } } QueryHttp import java.io.IOException; import okhttp3.HttpUrl; import okhttp3.OkHttpClient; import okhttp3.Request; import okhttp3.Response; /** * Created by Administrator on 2017/11/27. */ public class QueryHttp { public static void main(String args[]) { OkHttpClient client = new OkHttpClient(); HttpUrl httpUrl = HttpUrl.parse(&quot;https://api.heweather.com/x3/weather&quot;). newBuilder(). addQueryParameter(&quot;city&quot;, &quot;beijing&quot;). addQueryParameter(&quot;key&quot;, &quot;d17ce22ec5404ed883e1cfcaca0ecaa7&quot;). build(); String url = httpUrl.toString(); System.out.println(httpUrl.toString()); Request request = new Request.Builder().url(url).build(); try { Response response = client.newCall(request).execute(); if (response.isSuccessful()) { System.out.println(response.body().string()); } } catch (IOException e) { e.printStackTrace(); } } } HeadHttp import java.io.IOException; import okhttp3.Headers; import okhttp3.OkHttpClient; import okhttp3.Request; import okhttp3.Response; /** * Created by Administrator on 2017/11/27. */ /** * 请求头 */ public class HeadHttp { public static void HadeHttp(String url){ OkHttpClient client =new OkHttpClient(); Request request = new Request.Builder().url(url). addHeader(&quot;User-Agent&quot;,&quot;from nate http&quot;).build(); try { Response response = client.newCall(request).execute(); if(response.isSuccessful()){ Headers headers = response.headers(); for(int i=0;i&lt;headers.size();i++){ System.out.println(headers.name(i)+&quot;:&quot;+headers.value(i)); } } } catch (IOException e) { e.printStackTrace(); } } public static void main(String []args){ HadeHttp(&quot;http://www.baidu.com&quot;); } } 同步和异步请求比较 import java.io.IOException; import okhttp3.Call; import okhttp3.Callback; import okhttp3.OkHttpClient; import okhttp3.Request; import okhttp3.Response; /** * Created by Administrator on 2017/11/27. */ /**同步 * */ public class AsyncHttp { public static void SendHttp(String url){ OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder().url(url).build(); try { Response response = client.newCall(request).execute(); if (response.isSuccessful()){ System.out.println(response.body().string()); } } catch (IOException e) { e.printStackTrace(); } } /** *异步 * */ public static void SendAsyncHttp(String url){ System.out.println(Thread.currentThread().getId()); OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder().url(url).build(); client.newCall(request).enqueue(new Callback() { @Override public void onFailure(Call call, IOException e) { } @Override public void onResponse(Call call, Response response) throws IOException { if (response.isSuccessful()){ System.out.println(Thread.currentThread().getId()); } } }); } public static void main(String [] args){ SendAsyncHttp(&quot;http://www.baidu.com&quot;); // SendHttp(&quot;http://www.baidu.com&quot;); } }","categories":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Android/"}]},{"title":"微信支付及支付宝支付集成","slug":"WeChatAlipayPayIntegr","date":"2014-12-11T04:19:15.000Z","updated":"2018-03-18T04:25:57.390Z","comments":true,"path":"2014/12/11/WeChatAlipayPayIntegr/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2014/12/11/WeChatAlipayPayIntegr/","excerpt":"","text":"文章转载自互联网 1.微信支付 1.微信官方的集成文档 2.微信官方资源下载 首先官方文档实在是没有看懂，里面有很多东西都没有提及到，反正当时我看的时候就没有看懂可能是能力有限吧！ 先说一下我们这边的需求吧，我们这边订单处理是在服务器，没有在app内进行，一些字段都是从服务器返回的，这里只要请求之后，唤起微信支付就算是完成了，还是很简单的一个操作，下面我们就一步一步往下说吧！集成步骤如下：1.首先就是导入最新的SDK，这个从微信官方资源下载处就可以下载（这里就不说了）2.添加必要的权限 &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt; 3.创建一个wxapi的包并且创建一个WXEntryActivity类这里有几点要注意以下： 1.首先这个包必须在你项目的根目录下创建的，例如应用程序的包名为net.sourceforge.simcpux，则新添加的应该在net.sourceforge.simcpux.wxapi下面） 2.在AndroidManifest中添加相应的标签 &lt;activity android:name=&quot;.wxapi.WXEntryActivity&quot; android:configChanges=&quot;keyboardHidden|orientation|screenSize&quot; android:exported=&quot;true&quot; android:screenOrientation=&quot;portrait&quot; android:theme=&quot;@android:style/Theme.Translucent.NoTitleBar&quot;/&gt; 4.关于APPID存放问题 关于这个APPID的存放，因为做了分享，所以我就直接存放到本地了的静态字段中了，还有就是从服务器请求，其实从服务器请求我有一点我不太明白之后再说！5.创建一个WXPayEntryActivity类 创建的这个类我就直接放在wxapi中了，不知都放在别的地方会不会有什么问题，没有尝试过。这个类就是用来支付回调的类了。关于这个类有几点说明： 1.这个类是集成Activity的实现IWXAPIEventHandler接口的，别忘了在AndroidManifest注册，否则不走回调的！ &lt;activity android:name=&quot;.wxapi.WXPayEntryActivity&quot; android:exported=&quot;true&quot; android:launchMode=&quot;singleTop&quot;/&gt; 2.在onCreat()方法中要注册到微信，这里要注意这个是你微信成功签名的那个APPID private IWXAPI api; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); //这里面的APPID就是存放在本地的微信的ID api = WXAPIFactory.createWXAPI(this, Constants.ACCOUNT.APP_ID); api.handleIntent(getIntent(), this); } 3.在onResp(BaseResp resp)方法中处理回调数据，也就是处理回调失败啊，成功啊什么的！ @Override public void onResp(BaseResp resp) { Logger.e(&quot;WXPayEntryActivity回调微信支付的结果errCode = &quot; + resp.errCode); if (resp.getType() == ConstantsAPI.COMMAND_PAY_BY_WX) { int errCode = resp.errCode; if (errCode == -1) {/*支付失败*/ Toast.makeText(this, &quot;支付失败&quot;, Toast.LENGTH_LONG).show(); } else if (errCode == 0) {/*支付成功*/ Toast.makeText(this, &quot;支付成功&quot;, Toast.LENGTH_SHORT).show(); EventBusUtils.post(new EventBusWechatGoldBean()); } else if (errCode == -2) {/*取消支付*/ Toast.makeText(this, &quot;取消支付&quot;, Toast.LENGTH_LONG).show(); } finish(); } } 6.之后就可以在相应的地方从服务器获取相应的参数调用微信支付了 调用的代码如下： /** * 唤起微信充值界面 */ private void payWechat(WechatGoldBean wechatGoldBean) { PayReq req = new PayReq(); req.appId = wechatGoldBean.getAppid(); req.partnerId = wechatGoldBean.getPartnerid(); req.prepayId = wechatGoldBean.getPrepayid(); req.nonceStr = wechatGoldBean.getNoncestr(); req.timeStamp = wechatGoldBean.getTimestamp(); req.packageValue = &quot;Sign=WXPay&quot;; req.sign = wechatGoldBean.getSign(); IWXAPI api = WXAPIFactory.createWXAPI(mContext, wechatGoldBean.getAppid()); api.sendReq(req); } 这里WechatGoldBean是从服务器请求来的实体类，这里面封装了关于微信支付的所有订单信息，这样做的好处就是生成订单服务器做比较安全，第二也省去了自己的麻烦。到了这里基本上都能唤起微信支付了常见问题： 关于微信的签名要说明的问题：首先按照微信的签名的话，一般步骤都可以往下走，但是有一点需要注意就是签完名之后，如果你打包成正式版的话也就是releasea签名的话要用正式的包安装才能唤起微信，否则会出错的，如果要是想使用Dug签名的话，你要把签名后的keystore替换掉android studio的默认签名就可以使用了。关于微信支付能只能想到这么多了，基本上集成就这么多问题，有什么不懂得欢迎在下方留言，看到了我会第一时间回复！！！2.支付宝支付 1.支付宝官方集成文档2.支付宝官方资源下载 其实支付宝支付的话还是比较简单的按照Demo集成的话基本上没有什么问题就是导入几个类就可以了。 还是先说一下我们这边的需求，还是订单处理在服务器这边，没有在app内进行，一些字段都是从服务器返回的，这里只要请求之后，唤起支付宝支付就算完成了，比较简单，下面一步一步往下说吧！集成步骤如下：1.首先就是导入最新的SDK，这个从支付宝官方资源下载处就可以下载（这里就不说了）2.添加必要的权限 &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt; 3.在AndroidManifest中添加相应的标签 &lt;activity android:name=&quot;com.alipay.sdk.app.H5PayActivity&quot; android:configChanges=&quot;orientation|keyboardHidden|navigation&quot; android:exported=&quot;false&quot; android:screenOrientation=&quot;behind&quot; &gt; &lt;/activity&gt; &lt;activity android:name=&quot;com.alipay.sdk.auth.AuthActivity&quot; android:configChanges=&quot;orientation|keyboardHidden|navigation&quot; android:exported=&quot;false&quot; android:screenOrientation=&quot;behind&quot; &gt; &lt;/activity&gt; 4.支付接口调用 这里说明一下，支付宝调用的时候必须在异步线程中调用！切记 public void payAlipay(final ALipayGoldBean aLipayGoldBean) { Runnable payRunnable = new Runnable() { @Override public void run() { PayTask alipay = new PayTask((DiamondActivity) mContext); Map&lt;String, String&gt; result = alipay.payV2(aLipayGoldBean.getPayInfo(), true); Message msg = new Message(); msg.what = SDK_PAY_FLAG; msg.obj = result; mHandler.sendMessage(msg); } }; Thread payThread = new Thread(payRunnable); payThread.start(); } 这里说明一下：这个ALipayGoldBean是从服务器请求过来的，里面就一个payInfo参数，其实就是payV2()所需要的定单的信息(orderInfo)！5.支付结果的处理 官方文档上说有两种处理方式，但是作为APP我只按第一种处理方式进行的，第二种没有研究！ private Handler mHandler = new Handler() { @Override public void handleMessage(Message msg) { switch (msg.what) { case SDK_PAY_FLAG: @SuppressWarnings(&quot;unchecked&quot;) PayResult payResult = new PayResult((Map&lt;String, String&gt;) msg.obj); String resultStatus = payResult.getResultStatus(); // 判断resultStatus 为9000则代表支付成功 if (TextUtils.equals(resultStatus, &quot;9000&quot;)) {/*支付成功*/ Toast.makeText(mContext, &quot;支付成功&quot;, Toast.LENGTH_SHORT).show(); } else {/*支付失败*/ Toast.makeText(mContext, &quot;支付失败&quot;, Toast.LENGTH_SHORT).show(); } break; } } }; 这里有几点说明的问题：1.这个PayResult从Demo中直接复制过来就行，要不没有的；如果你不想复制，好的在下面： public class PayResult { private String resultStatus; private String result; private String memo; public PayResult(Map&lt;String, String&gt; rawResult) { if (rawResult == null) { return; } for (String key : rawResult.keySet()) { if (TextUtils.equals(key, &quot;resultStatus&quot;)) { resultStatus = rawResult.get(key); } else if (TextUtils.equals(key, &quot;result&quot;)) { result = rawResult.get(key); } else if (TextUtils.equals(key, &quot;memo&quot;)) { memo = rawResult.get(key); } } } @Override public String toString() { return &quot;resultStatus={&quot; + resultStatus + &quot;};memo={&quot; + memo + &quot;};result={&quot; + result + &quot;}&quot;; } /** * @return the resultStatus */ public String getResultStatus() { return resultStatus; } /** * @return the memo */ public String getMemo() { return memo; } /** * @return the result */ public String getResult() { return result; } } 2.关于Handler内存泄漏的问题，自己可以改的，如果改不了百度一下就可以了。至此支付宝支付就算集成完毕了，是不是很简单！作为小白的我们真的要多学习，多看别人的代码，学习这个东西就是这样，不论什么天才和小白，没有什么捷径可以走，只有不断的学习才能跟得上时代，不被淘汰！座右铭：只有自己强大才能无所畏惧！","categories":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Android/"}]},{"title":"Java接口回调，Android接口回调读书笔记","slug":"InterfaceCallback","date":"2014-05-13T04:04:35.000Z","updated":"2018-03-18T04:49:39.863Z","comments":true,"path":"2014/05/13/InterfaceCallback/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2014/05/13/InterfaceCallback/","excerpt":"","text":"原CSDN博客已弃用，文章会逐渐迁移过来。 单看文章比较难理解，照着多敲几遍代码就理解了 回调就是A类中调用B类中的某个方法C，然后B类中反过来调用A类中的方法D，D这个方法就叫回调方法，这样子说你是不是有点晕晕的，其实我刚开始也是这样不理解，看了人家说比较经典的回调方式： Class A实现接口CallBack callback——背景1 class A中包含一个class B的引用b ——背景2 class B有一个参数为callback的方法f(CallBack callback) ——背景3 A的对象a调用B的方法 f(CallBack callback) ——A类调用B类的某个方法 C 然后b就可以在f(CallBack callback)方法中调用A的方法 ——B类调用A类的某个方法D 大家都喜欢用打电话的例子，好吧，为了跟上时代，我也用这个例子好了，我这个例子采用异步加回调 有一天小王遇到一个很难的问题，问题是“1 + 1 = ?”，就打电话问小李，小李一下子也不知道，就跟小王说，等我办完手上的事情，就去想想答案，小王也不会傻傻的拿着电话去等小李的答案吧，于是小王就对小李说，我还要去逛街，你知道了答案就打我电话告诉我，于是挂了电话，自己办自己的事情，过了一个小时，小李打了小王的电话，告诉他答案是2 /** * 这是一个回调接口 * @author xiaanming * */ public interface CallBack { /** * 这个是小李知道答案时要调用的函数告诉小王，也就是回调函数 * @param result 是答案 */ public void solve(String result); } /** * 这个是小王 * @author xiaanming * 实现了一个回调接口CallBack，相当于-----&gt;背景一 */ public class Wang implements CallBack { /** * 小李对象的引用 * 相当于-----&gt;背景二 */ private Li li; /** * 小王的构造方法，持有小李的引用 * @param li */ public Wang(Li li){ this.li = li; } /** * 小王通过这个方法去问小李的问题 * @param question 就是小王要问的问题,1 + 1 = ? */ public void askQuestion(final String question){ //这里用一个线程就是异步， new Thread(new Runnable() { @Override public void run() { /** * 小王调用小李中的方法，在这里注册回调接口 * 这就相当于A类调用B的方法C */ li.executeMessage(Wang.this, question); } }).start(); //小网问完问题挂掉电话就去干其他的事情了，诳街去了 play(); } public void play(){ System.out.println(&quot;我要逛街去了&quot;); } /** * 小李知道答案后调用此方法告诉小王，就是所谓的小王的回调方法 */ @Override public void solve(String result) { System.out.println(&quot;小李告诉小王的答案是---&gt;&quot; + result); } } /** * 这个就是小李啦 * @author xiaanming * */ public class Li { /** * 相当于B类有参数为CallBack callBack的f()----&gt;背景三 * @param callBack * @param question 小王问的问题 */ public void executeMessage(CallBack callBack, String question){ System.out.println(&quot;小王问的问题---&gt;&quot; + question); //模拟小李办自己的事情需要很长时间 for(int i=0; i&lt;10000;i++){ } /** * 小李办完自己的事情之后想到了答案是2 */ String result = &quot;答案是2&quot;; /** * 于是就打电话告诉小王，调用小王中的方法 * 这就相当于B类反过来调用A的方法D */ callBack.solve(result); } } /** * 测试类 * @author xiaanming * */ public class Test { public static void main(String[]args){ /** * new 一个小李 */ Li li = new Li(); /** * new 一个小王 */ Wang wang = new Wang(li); /** * 小王问小李问题 */ wang.askQuestion(&quot;1 + 1 = ?&quot;); } } 通过上面的那个例子你是不是差不多明白了回调机制呢，上面是一个异步回调，我们看看同步回调吧，onClick（）方法 现在来分析分析下Android View的点击方法onclick（）;我们知道onclick()是一个回调方法，当用户点击View就执行这个方法，我们用Button来举例好了 //这个是View的一个回调接口 /** * Interface definition for a callback to be invoked when a view is clicked. */ public interface OnClickListener { /** * Called when a view has been clicked. * * @param v The view that was clicked. */ void onClick(View v); } package com.example.demoactivity; import android.app.Activity; import android.os.Bundle; import android.view.View; import android.view.View.OnClickListener; import android.widget.Button; import android.widget.Toast; /** * 这个就相当于Class A * @author xiaanming * 实现了 OnClickListener接口----&gt;背景一 */ public class MainActivity extends Activity implements OnClickListener{ /** * Class A 包含Class B的引用-----&gt;背景二 */ private Button button; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); button = (Button)findViewById(R.id.button1); /** * Class A 调用View的方法,而Button extends View-----&gt;A类调用B类的某个方法 C */ button.setOnClickListener(this); } /** * 用户点击Button时调用的回调函数，你可以做你要做的事 * 这里我做的是用Toast提示OnClick */ @Override public void onClick(View v) { Toast.makeText(getApplication(), &quot;OnClick&quot;, Toast.LENGTH_LONG).show(); } } 下面是View类的setOnClickListener方法，就相当于B类咯，只把关键代码贴出来 /** * 这个View就相当于B类 * @author xiaanming * */ public class View implements Drawable.Callback, KeyEvent.Callback, AccessibilityEventSource { /** * Listener used to dispatch click events. * This field should be made private, so it is hidden from the SDK. * {@hide} */ protected OnClickListener mOnClickListener; /** * setOnClickListener()的参数是OnClickListener接口------&gt;背景三 * Register a callback to be invoked when this view is clicked. If this view is not * clickable, it becomes clickable. * * @param l The callback that will run * * @see #setClickable(boolean) */ public void setOnClickListener(OnClickListener l) { if (!isClickable()) { setClickable(true); } mOnClickListener = l; } /** * Call this view&apos;s OnClickListener, if it is defined. * * @return True there was an assigned OnClickListener that was called, false * otherwise is returned. */ public boolean performClick() { sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED); if (mOnClickListener != null) { playSoundEffect(SoundEffectConstants.CLICK); //这个不就是相当于B类调用A类的某个方法D，这个D就是所谓的回调方法咯 mOnClickListener.onClick(this); return true; } return false; } } 这个例子就是Android典型的回调机制，看完这个你是不是更进一步的理解了回调机制呢？ 线程run()也是一个回调方法，当执行Thread的start（）方法就会回调这个run()方法，还有处理消息都比较经典等等 案例二、 接口回调简单理解就是：类A中调用B类的中方法C，而B又反过去调用A中的方法D，然后D称为A的回调方法。是不是心中有一万只草泥马在奔腾，到底说的是什么。感觉像是你中有我，我中有你，纠缠不清。举个通俗易懂的例子，比如顾客是A，厨师是B。面粉是接口Callback。然后面粉的吃法D是在顾客A的手中，厨师B有包子的做法C。现在需求是A有面粉，想吃包子，但是A是不会做包子，就需要去找厨师，让他调方法C做包子，A就把面粉Callback给了厨师，至于厨师怎么做，A不管，A只要你做好了给我一个结果（包子）就OK了。至于包子怎么吃，我是直接吃，还是蘸点醋吃，那是A的事了（A怎么吃的过程就是方法D里具体执行的代码）。下面结合一个简单的例子看就容易多了。首先是定义接口（面粉）： package com.example.interfacecallbackdemo; public interface Callback { //因为是一堆面粉，肯定是没法吃的，所以没有具体的方法体，俗称“吃法” public void D(String result); } 然后定义A类（客户）： package com.example.interfacecallbackdemo; public class A implements Callback{ /** * B类引用 */ private B b; public A(B b) { this.b = b; } /** * A类通过该方法调用B的方法C（可理解为找到厨师并将面粉给他）。 */ public void selectMenu(){ b.C(this); } /** * A类中的D方法，也称为A类的回调方法（厨师做好包子将包子（result）返回给顾客A） */ @Override public void D(String result) { System.out.print(result); } } 然后是B类： package com.example.interfacecallbackdemo; public class B { /** * B类的C方法（接受面粉Callback,然后开工做包子，做好后返回给客户A）。 */ public void C(Callback callback){ String result = &quot;2&quot;; callback.D(result); } } 再加上一个执行的对象，我是利用android中button调用的： package com.example.interfacecallbackdemo; import android.app.Activity; import android.os.Bundle; import android.view.Menu; import android.view.MenuItem; import android.view.View; import android.view.View.OnClickListener; import android.widget.Button; public class MainActivity extends Activity implements OnClickListener{ private A a; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); findViewById(R.id.btn_main) .setOnClickListener(this); a = new A(new B()); } @Override public void onClick(View v) { switch (v.getId()) { case R.id.btn_main: a.selectMenu(); break; default: break; } } } （ABCD分别对应什么自己脑补，很easy吧）前面说的是A 调用B中的方法C，B又反过来调用A中的方法D。在代码中我就直接用ABCD ,简单、直接、粗暴。但是，B类的C方法的参数不必一定要把Callback作为参数，如果C方法中没有这个参数，那在B类中一定要在其它地方把Callback接收进来。比如，我把B类稍微改动一下： package com.example.interfacecallbackdemo; public class B { private Callback callback; public B(Callback callback){ this.callback = callback; } /** * B类的C方法 */ public void C(){ String result = &quot;2&quot;; callback.D(result); } } 此时A类也要做相应的调整： package com.example.interfacecallbackdemo; import android.util.Log; public class A { /** * B类引用 */ private B b; /** * A类同过该方法调用B类的C方法 */ public void selectMenu(){ b = new B(new Callback() { @Override public void D(String result) { System.out.print(result); } }); b.C(); } } 呃，这个算是标准版的变异版，其实也是很简单的，毕竟这种可能是大家项目中实际中会见到而不至于弄不清楚，但是有一点，C方法中一定会有接口的实例对象调用其抽象方法。其实我们不需要按接口回调的定义去对比，重要的是理解其原理机制，只需记住，哪个类传递Callback实例对象过去的，就是我们所说的A，接受的就是B。接口回调在android中是非常常见的，典型的就是各种监听器了，如果去分析下源码，你就会发现跟上面得那个例子大同小异。","categories":[{"name":"Java","slug":"Java","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Java/"}]},{"title":"Retrofit框架读书总结笔记（一）","slug":"RetrofitReadNotesOne","date":"2014-05-11T03:55:21.000Z","updated":"2018-03-18T04:29:21.995Z","comments":true,"path":"2014/05/11/RetrofitReadNotesOne/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2014/05/11/RetrofitReadNotesOne/","excerpt":"","text":"原CSDN博客已弃用，文章会逐渐迁移过来。 转帖请注明本文出自weimeig的博客（http://blog.csdn.net/weimeig/article/details/78656178），请尊重他人的辛勤劳动成果，谢谢 一、添加依赖 build.gradle dependencies { compile &apos;com.squareup.retrofit2:retrofit:2.0.2&apos; // Retrofit库 compile &apos;com.squareup.okhttp3:okhttp:3.1.2&apos; // Okhttp库 } 点击右上角Sync Now 二、 （1）RestService类 import java.util.WeakHashMap; import okhttp3.MultipartBody; import okhttp3.RequestBody; import okhttp3.ResponseBody; import retrofit2.Call; import retrofit2.http.Body; import retrofit2.http.DELETE; import retrofit2.http.FieldMap; import retrofit2.http.FormUrlEncoded; import retrofit2.http.GET; import retrofit2.http.Multipart; import retrofit2.http.POST; import retrofit2.http.PUT; import retrofit2.http.Part; import retrofit2.http.QueryMap; import retrofit2.http.Streaming; import retrofit2.http.Url; /** * Created by Administrator on 2017/11/28. */ public interface RestService { @GET Call&lt;String&gt; get(@Url String url, @QueryMap WeakHashMap&lt;String, Object&gt; params); @FormUrlEncoded @POST Call&lt;String&gt; post(@Url String url, @FieldMap WeakHashMap&lt;String, Object&gt; params); @POST Call&lt;String&gt; postRaw(@Url String url, @Body RequestBody body); @FormUrlEncoded @PUT Call&lt;String&gt; put(@Url String url, @FieldMap WeakHashMap&lt;String, Object&gt; params); @PUT Call&lt;String&gt; putRaw(@Url String url, @Body RequestBody body); @DELETE Call&lt;String&gt; delete(@Url String url, @QueryMap WeakHashMap&lt;String, Object&gt; params); @Streaming @GET Call&lt;ResponseBody&gt; download(@Url String url, @QueryMap WeakHashMap&lt;String, Object&gt; params); @Multipart @POST Call&lt;String&gt; upload(@Url String url, @Part MultipartBody.Part file); }","categories":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Android/"}]},{"title":"AndroidStudio导入网上下载的代码慢及AndroidStudio不提示代码的解决方法","slug":"ASImportCodeNotPrompt","date":"2014-03-18T04:01:25.000Z","updated":"2018-03-18T04:03:35.817Z","comments":true,"path":"2014/03/18/ASImportCodeNotPrompt/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2014/03/18/ASImportCodeNotPrompt/","excerpt":"","text":"原CSDN博客已弃用，文章会逐渐迁移过来。 转帖请注明本文出自weimeig的博客（http://blog.csdn.net/weimeig/article/details/78854345），请尊重他人的辛勤劳动成果，谢谢 当出现AndroidStudio导入网上下载的代码慢及AndroidStudio不提示代码时，多数是因为Google被墙，导致gradle无法更新下来。 解决的方法是，先在本地创建一个Android项目，然后找到 随后再找到 完成这两步的目的是，通过找到本地的gradle配置，将网上下载的不同配置的项目的gradle配置改成读本地配置，来解决Google被墙无法更新网上可行版本的问题。通常设置完这两个地方，再点击一下AndroidStudio上方工具栏里的BuiId下的Clean Project ，结束后点击RebuiId Project,然后再点击一下这个按钮， 同步一下，问题就可以解决了 一般来说，网上下载的项目更新慢，或编译器无代码提示，都是因为这个原因引起。","categories":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Android/"}]},{"title":"Android第三方分享集成","slug":"AndroidThirdShare","date":"2014-03-18T03:55:21.000Z","updated":"2018-03-18T04:00:49.647Z","comments":true,"path":"2014/03/18/AndroidThirdShare/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2014/03/18/AndroidThirdShare/","excerpt":"","text":"原CSDN博客已弃用，文章会逐渐迁移过来。 转帖请注明本文出自weimeig的博客（http://blog.csdn.net/weimeig/article/details/78818943），请尊重他人的辛勤劳动成果，谢谢 一、环境集成 二、调用方法 一、环境集成 请看我的另一篇文章，里面详尽的介绍了整个集成的流程。分享只是在那个前提下多写一个分享的方法。 文章链接：http://blog.csdn.net/weimeig/article/details/78818085 二、调用方法 `/** * 第三方分享方法 * Created by weimei on 2017/12/16. * Email:ucvs@qq.com */ public void share(){ OnekeyShare oks = new OnekeyShare(); //关闭sso授权 oks.disableSSOWhenAuthorize(); // 分享时Notification的图标和文字 2.5.9以后的版本不 调用此方法 //oks.setNotification(R.drawable.ic_launcher, getString(R.string.app_name)); // title标题，印象笔记、邮箱、信息、微信、人人网和QQ空间使用 oks.setTitle(&quot;分享&quot;); // titleUrl是标题的网络链接，仅在人人网和QQ空间使用 oks.setTitleUrl(&quot;http://blog.csdn.net/weimeig&quot;); // text是分享文本，所有平台都需要这个字段 oks.setText(&quot;我是分享文本&quot;); // imagePath是图片的本地路径，Linked-In以外的平台都支持此参数 oks.setImageUrl(&quot;http://www.ld12.com/upimg358/20160130/23120952396496.jpg&quot;);//确保SDcard下面存在此张图片 // url仅在微信（包括好友和朋友圈）中使用 oks.setUrl(&quot;http://blog.csdn.net/weimeig&quot;); // comment是我对这条分享的评论，仅在人人网和QQ空间使用 oks.setComment(&quot;我是测试评论文本&quot;); // site是分享此内容的网站名称，仅在QQ空间使用 oks.setSite(getString(R.string.app_name)); // siteUrl是分享此内容的网站地址，仅在QQ空间使用 oks.setSiteUrl(&quot;http://blog.csdn.net/weimeig&quot;); oks.setCallback(new PlatformActionListener() { @Override public void onComplete(Platform platform, int i, HashMap&lt;String, Object&gt; hashMap) { /** * 不得到优惠券 */ //分享成功逻辑在这里处理 } @Override public void onError(Platform platform, int i, Throwable throwable) { //分享失败逻辑在这里处理 } @Override public void onCancel(Platform platform, int i) { //分享取消逻辑在这里处理 } }); // 启动分享GUI oks.show(this); }` 调用时候，在调用的地方使用 share(); 即可 如果分享的图标和渠道，不想要那么多，在项目下的app文件夹下的libs文件夹内删除对应的jar包即可。 例如不想要微信分享，直接删除ShareSDK-Wechat-Favorite-3.1.2.jar这个jar包，分享的时候就没有这个图标和对应的分享渠道了。 项目Demo下载 http://download.csdn.net/download/weimeig/10161093","categories":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Android/"}]},{"title":"Android第三方登录集成","slug":"AndroidThirdLogin","date":"2014-03-16T19:40:19.000Z","updated":"2018-03-18T03:56:07.999Z","comments":true,"path":"2014/03/17/AndroidThirdLogin/","link":"","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/2014/03/17/AndroidThirdLogin/","excerpt":"","text":"原CSDN博客已弃用，文章会逐渐迁移过来。 转帖请注明本文出自weimeig的博客（http://blog.csdn.net/weimeig/article/details/78818085）， 请尊重他人的辛勤劳动成果，谢谢 ShareSDK集成 一、集成 二、第三方开发平台注册 三、项目中使用 一、集成 到mob.com下载ShareSDK，选择要集成的功能并下载，下载好后，解压，并点击QuickIntegrater.rar生成需要功能，得到Sample文件夹，生成时候记得填写项目包名才点击生成，不然会报错。 （1）将Sample文件夹的libs文件夹里的jar包复制到项目下的app文件夹下的libs文件夹内。 （2）res文件夹内的文件，不做任何改名更改，复制到项目下的app文件夹下的res文件夹内。 （3）将ShareSDK.xml文件复制到项目下的app文件夹下的src下的main文件夹下的assets文件夹中，如果没有这个文件夹则创建一个。 （4）将src文件夹内复制到项目下的app文件夹下的src下的main文件夹下的java文件夹中，与自己原包名项目并列。 （5）更改AndroidManifest.xml文件内应用权限，照着官方文档填写即可，或者下载本文提供的demo，从demo中复制AndroidManifest.xml文件内权限到自己的项目 ( 6 )AndroidManifest.xml文件内设置您从Mob开发者后台中得到的Appkey和AppSecret，如 此时如果有地方报红，点击AndroidStudio上方工具栏里的BuiId下的Clean Project ，结束后点击RebuiId Project,然后再点击一下这个按钮， 原因是新引入的包需要同步一下，就不报红了。 集成完成。 二、第三方开发平台注册 如需要集成第三方登录是QQ、微信、微博。则分别到对应的第三方开放平台注册账号，如微信是微信第三方开放平台，在平台选择开启登录功能，然后填写完应用相关信息后，得到AppId和AppSecret将两者保存下来，一会第三步要用到。这里需要注意的是，平台填写的应用信息中，包名和应用签名，要和app对应。最后面附上怎么查看应用签名的方法。 特别注明：新浪微博的话，还需要在开放平台里选择回调接口地址，在开放平台应用信息附近找到OAuth2.0 授权设置编辑，设置微博回调地址。 比如官方默认的回调地址（默认的也可以使用）： 授权回调页：http://sns.whalecloud.com/sina2/callback取消授权回调页：http://sns.whalecloud.com/sina2/callback 三、项目中使用 （1）将你在第三方开发平台申请到的AppId和AppSecret填写到src下的main文件夹下的assets文件夹内的ShareSDK.xml文件中，替换掉mob提供的初始的。微博的话，还需要在这个文件里面的微博的配置里，设置RedirectUrl这个参数，微博官方默认的是 RedirectUrl=”http://sns.whalecloud.com/sina2/callback&quot; 如果你申请开发平台时用了默认的，可以设置为这个 （2）第三方登录的方法 `/** * 第三方登录方法 * Created by weimei on 2017/12/16. * Email:ucvs@qq.com */ private void thirdLogin(String platformName,final String backType) { Platform wechat = ShareSDK.getPlatform(platformName); wechat.SSOSetting(false); //设置false表示使用SSO授权方式 if(wechat.isAuthValid()){ wechat.removeAccount(true); } wechat.setPlatformActionListener(new PlatformActionListener() { @Override public void onComplete(Platform platform, int i, HashMap&lt;String, Object&gt; hashMap) { Log.d(TAG, &quot;onComplete: &quot;+i+new Gson().toJson(hashMap)); if (i == Platform.ACTION_USER_INFOR) { final PlatformDb platDB = platform.getDb();//获取数平台数据DB //通过DB获取各种数据 platDB.getToken(); platDB.getUserGender(); platDB.getUserIcon(); platDB.getUserId(); platDB.getUserName(); Log.d(TAG, &quot;onComplete: &quot;+ platDB.getToken()+&quot;-&quot;+ platDB.getUserId()+&quot;-&quot;+ platDB.getUserName()); runOnUiThread(new Runnable() { @Override public void run() { // platDB.getUserId()是唯一的 //这里写你的业务逻辑，如网络请求 // mPresenter.trilateralLogin(backType,platDB.getUserId(),platDB.getUserName(), // platDB.getUserIcon(),platDB.getUserGender(),LoginActivity.this); } }); } } @Override public void onError(Platform platform, int i, Throwable throwable) { Log.d(TAG, &quot;onError: &quot;+throwable.toString()); } @Override public void onCancel(Platform platform, int i) { /** * 给用户取消的提示 */ } }); // 设置分享事件回调 wechat.authorize();//单独授权 wechat.showUser(null); }` 然后在需要使用第三方登录的地方调用该方法即可 如果此时报红，则用第一步教的那个方法，同步一下，就不报红了。 此时 QQ调用时，如： thirdLogin(QQ.NAME,&quot;AndroidQQ&quot;); 微信调用时，如： thirdLogin(Wechat.NAME,&quot;AndroidWechat&quot;); 微博调用时，如： thirdLogin(SinaWeibo.NAME,&quot;Androidweibo&quot;); 其中第一个参数的，如：QQ.NAME，是第三方规定的，不可随意更改，第二个参数，是来源，如果你后台的url不需要这个参数，直接删除即可，同时也在thirdLogin方法里面删除即可。 附：查看应用签名的方法。 用密钥打包apk，打包的时候，选择生成release版本，切记不要生成debug版本。然后安装到手机中。 同时安装下面提供的这个apk。打开这个apk，输入你的应用包名，点击生成，生成的这个就是你的安卓签名。 注意这个是要用你发布app的那个密钥去生成apk，并且输入的包名和你发布的app的包名一致，满足这两个要求前提下，才能生成一致的安卓签名。 安卓签名生成软件 http://download.csdn.net/download/weimeig/10161075 项目Demo下载 http://download.csdn.net/download/weimeig/10161093","categories":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=542616848/tags/Android/"}]}]}